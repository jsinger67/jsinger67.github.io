<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Grammar Description Syntax - The Parol Parser Generator</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Parol Parser Generator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-syntax-of-parols-grammar-description"><a class="header" href="#the-syntax-of-parols-grammar-description">The Syntax of <code>parol</code>'s Grammar Description</a></h1>
<p>The definition of the PAR grammar is provided in the PAR grammar
<a href="https://github.com/jsinger67/parol/blob/main/crates/parol/src/parser/parol.par">itself</a>.</p>
<p>This grammar is concise and most programmers should be familiar with it. However, there are several
specifics described here. First, note the built-in support for language
comments.</p>
<p>Using <code>%line_comment</code> and <code>%block_comment</code>, you can easily define your language's comments. For
example, you can define comments as in the calc example
<code>calc.par</code>:</p>
<pre><code class="language-parol">%line_comment "//"
%block_comment  "/\*" "\*/"
</code></pre>
<p>You can supply more than one of these two comment declarations. They are all considered valid
comments.</p>
<p>In contrast to EBNF, you use C-like line comments starting with two slashes (//) and block comments
(/* ... */) in PAR files. This is a result of the close relationship between PAR grammar and
bison's grammar.</p>
<p><code>parol</code> does not simply discard language comments. They are provided during parsing via a new method
<code>&lt;UserType&gt;GrammarTrait::on_comment</code>, which is called for each comment in order of appearance each
time before the parser consumes a normal token from the token stream.
The method has a default implementation, and users only need to provide their own implementation if
they are interested in language comments.</p>
<p>This is minimal support, but it can greatly improve usability.</p>
<h2 id="defining-the-grammar-type"><a class="header" href="#defining-the-grammar-type">Defining the Grammar Type</a></h2>
<p>In the global header section you can define the grammar type you want to use in your grammar
description.</p>
<p>The default grammar type is LL(k) and can be omitted.</p>
<pre><code class="language-parol">%grammar_type 'LL(k)'
</code></pre>
<p>You can define the grammar type as LALR(1) this way:</p>
<pre><code class="language-parol">%grammar_type 'LALR(1)'
</code></pre>
<h2 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case Sensitivity</a></h2>
<p>Non-terminals are treated as case-sensitive, i.e., "list" and "List" are different symbols. However,
it is not recommended to rely on this in your grammar definition. It is much better to keep
capitalization consistent throughout your grammar.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p><code>parol</code>'s input language consists of two sections divided by the <code>%%</code> token. Above it are
declarations, of which only the first <code>%start</code> declaration is mandatory. It declares the start
symbol of your grammar.
The second section below the <code>%%</code> token contains the actual grammar description in the form of
several
productions. At least one production must exist.</p>
<h2 id="the-start-symbol"><a class="header" href="#the-start-symbol">The Start Symbol</a></h2>
<p>It is important to note that the start symbol of the grammar must always be declared with the
<code>%start</code> declaration. It is the very first declaration in the PAR file.</p>
<pre><code class="language-parol">%start Grammar
</code></pre>
<h2 id="scanner-control"><a class="header" href="#scanner-control">Scanner Control</a></h2>
<!-- markdownlint-disable no-inline-html -->
<p>A scanner (aka lexer) is automatically created from all used terminal symbols. Terminal symbols can
also be associated with different scanner states. See section
<a href="#scanner-states">Scanner states</a> below for more details.</p>
<!-- markdownlint-enable no-inline-html -->
<h3 id="newline-handling"><a class="header" href="#newline-handling">Newline handling</a></h3>
<p>The scanner skips newlines automatically by default. To suppress this, use the <code>%auto_newline_off</code>
directive.
In that case, you must handle newline tokens yourself in your grammar.</p>
<h3 id="whitespace-handling"><a class="header" href="#whitespace-handling">Whitespace handling</a></h3>
<p>The scanner also skips whitespace automatically by default. To suppress this, use the <code>%auto_ws_off</code>
directive.
In that case, you must handle whitespace tokens yourself in your grammar.</p>
<h3 id="open-scanner-states"><a class="header" href="#open-scanner-states">Open scanner states</a></h3>
<p>Scanner modes can also be configured to tolerate unmatched tokens by specifying <code>%allow_unmatched</code>
in the scanner section of the grammar. This allows unmatched input to be ignored instead of
triggering an error, which can be useful in certain scenarios.</p>
<p><strong>Usage example:</strong></p>
<pre><code class="language-parol">// For scanner state INITIAL
%allow_unmatched

// For any scanner state defined
%scanner MyScanner {
    ...
    %allow_unmatched
}
</code></pre>
<p>This feature is opt-in and fully backward compatible; existing grammars are unaffected unless
<code>%allow_unmatched</code> is explicitly used.</p>
<p>See also the new example <code>allow_unmatched</code>.</p>
<h3 id="terminal-name-generation"><a class="header" href="#terminal-name-generation">Terminal name generation</a></h3>
<p>The names of the terminals are deduced from the content of the terminal itself. For instance, for a
terminal ":=" it creates the terminal name "ColonEqu", see generated parser for Oberon-0. If you
want this name to be more expressive, you can dedicate a separate production to the terminal, let's
say:</p>
<pre><code class="language-parol">Assign: ":=";
</code></pre>
<p>With this trick you define a so called "primary non-terminal for a terminal" (I coined it this way)
that instructs the name generation to name the terminal "Assign".</p>
<h3 id="terminal-representation"><a class="header" href="#terminal-representation">Terminal representation</a></h3>
<p><code>parol</code> supports three different styles of terminal representations, all of them being valid and
allowed.</p>
<ul>
<li>The <strong>string syntax</strong> (<code>"..."</code>). These terminals are treated as if they were <strong>regular expressions.</strong></li>
<li>The <strong>single quoted</strong> string literals (<code>'..'</code>) are <strong>literals or raw strings</strong>. The user does not
need to escape any regex meta character. This is used when you do not want to deal with regexes and
only use plain text. E.g.: <code>BlockBegin: '{'</code></li>
<li>The <strong>regular expression strings</strong> (<code>/../</code>), behaves exactly like the double quoted string, i.e.
they are treated as <strong>regular expressions</strong> but this style better conveys the intent. E.g.:
<code>Digits: /[\d]+/;</code></li>
</ul>
<p>Internally <code>parol</code> creates scanners on the basis of the <code>scnr2</code> crate and all terminals are
expressed as regular expressions eventually. You should be aware of this if you get strange errors
from regex generation and want to understand the problem.</p>
<p>Here is an example for a terminal in regular expression form:</p>
<pre><code class="language-parol">AddOperator: /\+|-/;
</code></pre>
<h3 id="terminal-conflicts"><a class="header" href="#terminal-conflicts">Terminal conflicts</a></h3>
<ul>
<li>Parol's scanner follows the longest match rule</li>
<li>Conflicts can only occur, if the matched tokens have the same length and are accepted by more than
one terminal type. In case of such a conflict between different terminals, terminals defined earlier
in the grammar have higher priority than those defined later. This allows you to influence the
priority of tokens with equal length. In all other cases, tokens with the longest match are
preferred.</li>
</ul>
<p>For example, if you have two terminals "-" and "--", <em>Minus</em> and <em>Decr</em>, the scanner will match
based on the longest match basis:</p>
<pre><code class="language-parol">Decr: /--/
    ;

Minus
    : /-/
    ;

</code></pre>
<p>An input string <code>-----</code> will match the decrement operator twice and then the minus operator once.</p>
<p>As an example for tokens with the same length consider following terminal definitions:</p>
<pre><code class="language-parol">// ❌
Ident: /[a-zA-Z_][a-zA-Z0-9_]*/
    ;

If: 'if'
    ;
</code></pre>
<p>In case of same length, the scanner will match based on the order of definition:</p>
<p>On input <code>if</code> it will match the <code>Ident</code> first. To make this work you have to move the terminal <code>If</code>
before the more general <code>Ident</code>:</p>
<pre><code class="language-parol">// ✅
If: 'if'
    ;

Ident: /[a-zA-Z_][a-zA-Z0-9_]*/
    ;
</code></pre>
<p>Defining <em>If</em> before <em>Ident</em> ensures the correct priority.</p>
<h4 id="context-aware-terminals"><a class="header" href="#context-aware-terminals">Context aware terminals</a></h4>
<p>You can also specify whether or not a certain token should follow your terminal.
To achieve this, you can use the two lookahead operators <code>?=</code> and <code>?!</code>. They work in principle like
similar operators provided by some regex engines. The scanner only tests for the existence or
absence of the specified regular expression on the right-hand side of these operators and if the
constraint holds it only matches the left-hand side. The right-hand side is not consumed.</p>
<pre><code class="language-parol">// Terminal for a function name using positive lookahead expression
// Matches the identifier part only if it is followed by an opening parenthesis
FunctionName: /[a-zA-Z_][a-zA-Z0-9_]*/ ?= '('
    ;

// Terminal for an identifier using negative lookahead expression
// Matches the identifier part only if it is not followed by an opening parenthesis
Identifier: /[a-zA-Z_][a-zA-Z0-9_]*/ ?! '('
    ;
</code></pre>
<h4 id="even-more-control-with-the-help-of-scanner-states"><a class="header" href="#even-more-control-with-the-help-of-scanner-states">Even more control with the help of scanner states</a></h4>
<p>You can define different scanner states and assign only the terminals you want to match in each mode.
For details, please see <a href="#scanner-states">Scanner states</a> below.</p>
<h4 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h4>
<p>❗ These four mechanisms, <strong>longest match rule</strong>, <strong>priority by order</strong>, <strong>lookahead expressions</strong>
and <strong>using multiple scanner states</strong> give you control over terminal conflicts.</p>
<h3 id="terminals-that-match-an-empty-string"><a class="header" href="#terminals-that-match-an-empty-string">Terminals That Match an Empty String</a></h3>
<p>Please note that terminals should always match non-empty text portions. This means that you have to
avoid terminals like this:</p>
<pre><code class="language-parol">/a?/, /a*/
</code></pre>
<p>Internally the tokenizer will enter a loop and match the empty string over and over again without
making progress in the input. Currently there is no check for this scenario in <code>parol_runtime</code>.</p>
<p>There is a <strong>workaround</strong> when you simply need possibly empty tokens, at least for the <code>?</code> and <code>*</code>
ones.
Make the token <code>+</code> and put their uses in optional expressions <code>[]</code>. This makes them non-empty and
also their possible emptiness explicit for the grammar:</p>
<pre><code class="language-parol">RuleWithWhiteSpaces: WhiteSpaces;
WhiteSpaces: /[ \t]*/;

// =&gt;

RuleWithWhiteSpaces: [ WhiteSpaces ];
WhiteSpaces: /[ \t]+/;
</code></pre>
<!-- markdownlint-disable no-inline-html -->
<h2 id=scanner-states>Scanner states</h2>
<!-- markdownlint-enable no-inline-html -->
<p><code>Parol</code> supports <strong>multiple scanner states</strong>. This feature is known from Flex as
<a href="https://www.cs.princeton.edu/~appel/modern/c/software/flex/flex_toc.html#TOC11">Start conditions</a>
and provides more flexibility in defining several scanners for several parts of your grammar.</p>
<blockquote>
<p>I use occasionally the term <strong>scanner mode</strong> which is synonymous to <strong>scanner state</strong>.</p>
</blockquote>
<p><code>Parol</code> provides comprehensive ways to control scanner states directly within your grammar
description thereby holding the principle of strict separation of grammar description and grammar
processing in semantic actions. This means no scanner switching in your code, but in the grammar
description. Only because of this rapid prototyping is possible.</p>
<h3 id="the-default-scanner-state-initial"><a class="header" href="#the-default-scanner-state-initial">The Default Scanner State INITIAL</a></h3>
<p>INITIAL is the name of the default scanner state 0. Its behavior is defined with <code>ScannerDirectives</code>
in the global <code>Declaration</code> section, such as:</p>
<pre><code class="language-parol">%line_comment "//"
%block_comment "/\*" "\*/"
</code></pre>
<h3 id="introduce-new-scanner-states-with-the-scanner-directive"><a class="header" href="#introduce-new-scanner-states-with-the-scanner-directive">Introduce new scanner states with the <code>%scanner</code> directive</a></h3>
<p>Use the <code>%scanner Name {...}</code> construct after the global <code>Declaration</code> section and before the <code>%%</code>
sign to introduce arbitrary scanner states. The identifier following the %scanner token defines the
name of the state which is used to refer to it from scanner state lists at terminals.</p>
<pre><code class="language-parol">%scanner String {
    %auto_newline_off
    %auto_ws_off
}

%scanner Pragma {
    %block_comment "\{" "\}"
}
</code></pre>
<p>You can place any of the <code>ScannerDirectives</code> within the block that defines the scanner state.</p>
<p>By default each scanner handles (and skips) whitespace and newlines. Use <code>%auto_newline_off</code> and
<code>%auto_ws_off</code> to modify each scanner state appropriately.</p>
<p>Associate terminals with scanner states by prefixing them with a list of comma separated state names
in angle brackets. Like this:</p>
<pre><code class="language-parol">StringDelimiter
    : &lt;String, INITIAL&gt;/"/
    ;
</code></pre>
<p>Scanner state references in different occurrences of the same terminal are accumulated. I.e.,</p>
<pre><code class="language-parol">&lt;State1&gt;"term"
...
&lt;State2&gt;"term"
</code></pre>
<p>will result in</p>
<pre><code class="language-parol">&lt;State1, State2&gt;"term"
</code></pre>
<p>Terminals without explicitly associated scanner state are implicitly associated with scanner state
INITIAL.</p>
<h3 id="scanner-switching"><a class="header" href="#scanner-switching">Scanner switching</a></h3>
<p>Scanner switching in Parol is managed by the scanner using the <code>%enter</code>, <code>%push</code>, and <code>%pop</code>
directives within the scanner specification:</p>
<ul>
<li><code>%enter</code>: Switches the scanner to a specific mode, replacing the current mode.</li>
<li><code>%push</code>: Pushes the current mode onto a stack and enters a new mode.</li>
<li><code>%pop</code>: Returns to the previous mode by popping the mode stack.</li>
</ul>
<p>These directives ensure that scanner state switching is handled consistently and reliably, preventing
token buffer desynchronization in LL(k) grammars with k &gt; 1. All scanner-related features are based
on the <a href="https://crates.io/crates/scnr2"><code>scnr2</code></a> crate.</p>
<p>Example usage:</p>
<pre><code class="language-parol">%on Rem %enter Cmnt
%on If, AssignOp, Print %enter Expr

%scanner Cmnt {
    %auto_newline_off
    %on EndOfLine %enter INITIAL
}
%scanner Expr {
    %auto_newline_off
    %on Then, Goto, EndOfLine %enter INITIAL
}
</code></pre>
<p>After the <code>%on</code> directive, specify a list of primary non-terminals. After the <code>%enter</code> directive,
specify the target scanner state. <code>%push</code> and <code>%pop</code> provide stack-based mode management.</p>
<p>Parol generates all data required by <code>scnr2</code> to construct valid and efficient scanners. Users do not
need to understand the internal configuration of <code>scnr2</code>.</p>
<h2 id="controlling-the-ast-generation"><a class="header" href="#controlling-the-ast-generation">Controlling the AST generation</a></h2>
<h3 id="omitting-grammar-symbols-from-the-ast"><a class="header" href="#omitting-grammar-symbols-from-the-ast">Omitting grammar symbols from the AST</a></h3>
<p>You can suffix grammar symbols (terminals and non-terminals) with a cut operator (<code>^</code>). This
instructs <code>parol</code> not to propagate them to the AST.</p>
<pre><code class="language-parol">Group: '('^ Alternations ')'^;
</code></pre>
<p>The AST type for the symbol <code>Group</code> will then only contain a member for the non-terminal
<code>Alternations</code>. The parentheses are left out.</p>
<h3 id="assigning-user-types-to-grammar-symbols"><a class="header" href="#assigning-user-types-to-grammar-symbols">Assigning user types to grammar symbols</a></h3>
<p>You can specify a user type to be inserted into the AST structure where the symbol would otherwise
have the originally generated type.
Add after a grammar symbol a colon followed by a user type name to instruct <code>parol</code> to use this type
instead. In your language implementation you have to provide fallible conversions from references of
the original generated types (<code>&amp;T</code>) to your types (<code>U</code>) by implementing the trait
<code>TryFrom&lt;&amp;T&gt; for U</code>.</p>
<p>In C#, the same mapping is achieved with constructors on your custom types. The constructors accept
the generated source types (for example <code>Token</code> for terminals, or generated non-terminal wrapper
types), and <code>parol</code> invokes these conversions in the generated mapping layer.</p>
<p>An example can be found in the <code>list</code> example.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'t&gt; TryFrom&lt;&amp;Token&lt;'t&gt;&gt; for Number {
    type Error = anyhow::Error;

    fn try_from(number: &amp;Token&lt;'t&gt;) -&gt; std::result::Result&lt;Self, Self::Error&gt; {
        Ok(Self(number.text().parse::&lt;u32&gt;()?))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can also define aliases for the user type names by inserting as many <code>%user_type</code> directives as
you want.</p>
<pre><code class="language-parol">%user_type Number = crate::list_grammar::Number
</code></pre>
<p>Then use these aliases behind the colons.</p>
<pre><code class="language-parol">Num: "0|[1-9][0-9]*": Number;
</code></pre>
<h3 id="define-user-types-for-non-terminals"><a class="header" href="#define-user-types-for-non-terminals">Define user types for non-terminals</a></h3>
<p>As of version 3.0 you can easily define a user type to which each occurrence of a certain
non-terminal should be automatically converted to.
This is done like in the following example:</p>
<pre><code class="language-parol">%nt_type ScannerState = crate::parser::parol_grammar::ScannerConfig
</code></pre>
<p>It is similar to <code>%user_type</code>, where you can define an alias for a user-defined type and then apply
it to individual symbols on the right-hand side of grammar productions. <code>%nt_type</code> cannot be used on
terminals, but it makes applying mappings to non-terminals much easier.
Here is the old version used in <code>parol</code> itself before (only partial)</p>
<pre><code class="language-parol">%user_type ScannerConfig = crate::parser::parol_grammar::ScannerConfig
// ...
%%
// ...
Prolog
: StartDeclaration { Declaration } { ScannerState: ScannerConfig }
;
</code></pre>
<p>And here is the new variant in which <code>%nt_type</code> is used.</p>
<pre><code class="language-parol">%nt_type ScannerState = crate::parser::parol_grammar::ScannerConfig
// ...
%%
// ...
Prolog
: StartDeclaration { Declaration } { ScannerState }
;
</code></pre>
<p>The non-terminal <code>ScannerState</code> is automatically converted to <code>ScannerConfig</code>.</p>
<p>It is semantically identical to using <code>%user_type</code> and applying it explicitly to each occurrence of
the non-terminal in the grammar.</p>
<p>This also applies to C#: <code>%nt_type</code> is usually the preferred way to define non-terminal mappings once
at grammar level, instead of repeating per-production annotations.</p>
<h3 id="user-defined-terminal-type"><a class="header" href="#user-defined-terminal-type">User-Defined Terminal Type</a></h3>
<p>As of version 3.0 you can easily define a user type to which each occurrence of a terminal should be
automatically converted to.
This is done like in the following example:</p>
<pre><code class="language-parol">%t_type crate::parol_ls_grammar::OwnedToken
</code></pre>
<p>There can be only one type defined to which all terminals are converted to.</p>
<p>More specifically, if several such instructions are given, the last one wins.</p>
<p>Here is the old version used in <code>parol-ls</code> itself before (only partial)</p>
<pre><code class="language-parol">%user_type OwnedToken = crate::parol_ls_grammar::OwnedToken
// ...
%%
// ...
ScannerSwitch
    : "%sc": OwnedToken '(': OwnedToken [ Identifier ] ')': OwnedToken
    | "%push": OwnedToken '(': OwnedToken Identifier ')': OwnedToken
    | "%pop": OwnedToken '(': OwnedToken ')': OwnedToken
    ;
</code></pre>
<p>And here is the new variant in which <code>%t_type</code> is used.</p>
<pre><code class="language-parol">%t_type crate::parol_ls_grammar::OwnedToken
// ...
%%
// ...
ScannerSwitch
    : "%sc" '(' [ Identifier ] ')'
    | "%push" '(' Identifier ')'
    | "%pop" '(' ')'
    ;
</code></pre>
<p>All terminals are automatically converted to <code>crate::parol_ls_grammar::OwnedToken</code>.</p>
<h3 id="define-user-defined-member-names"><a class="header" href="#define-user-defined-member-names">Define user-defined member names</a></h3>
<p>As of version 3.0 you can specify for each symbol on the right-hand side of a production how its
corresponding member in the generated struct should be named.</p>
<p>To achieve this you can use the newly introduced <code>@</code> operator.</p>
<pre><code class="language-parol">Declaration :
    ...
    | "%nt_type" Identifier@nt_name "="^ UserTypeName@nt_type
    ...
</code></pre>
<p>In this example the member for Identifier in the production will be named <code>nt_name</code> and the member
for UserTypeName will receive the name <code>nt_type</code> in the generated struct type for this production.</p>
<h2 id="semantic-actions"><a class="header" href="#semantic-actions">Semantic Actions</a></h2>
<p>Semantic actions are strictly separated from your grammar description.
You will use a generated trait with default implementations for each non-terminal of your grammar.
You can implement this trait in your grammar processing item and provide concrete implementations
for those non-terminals you are interested in.</p>
<p>In the chapter <a href="./OperatorPrecedence.html">Operator Precedence</a> there are some examples on how to
implement simple semantic actions.</p>
<p>A separate chapter <a href="./SemanticActions.html">Semantic Actions</a> deals more deeply with this topic.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="GettingStarted.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="OperatorPrecedence.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="GettingStarted.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="OperatorPrecedence.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
