<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Grammar description syntax - The Parol Parser Generator</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="History.html"><strong aria-hidden="true">2.</strong> History</a></li><li class="chapter-item expanded "><a href="GettingStarted.html"><strong aria-hidden="true">3.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="ParGrammar.html" class="active"><strong aria-hidden="true">4.</strong> Grammar description syntax</a></li><li class="chapter-item expanded "><a href="OperatorPrecedence.html"><strong aria-hidden="true">5.</strong> Operator precedence</a></li><li class="chapter-item expanded "><a href="OperatorAssociativity.html"><strong aria-hidden="true">6.</strong> Operator associativity</a></li><li class="chapter-item expanded "><a href="AstGeneration.html"><strong aria-hidden="true">7.</strong> AST generation</a></li><li class="chapter-item expanded "><a href="VanillaMode.html"><strong aria-hidden="true">8.</strong> Vanilla mode</a></li><li class="chapter-item expanded "><a href="SemanticActions.html"><strong aria-hidden="true">9.</strong> Semantic actions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Parol Parser Generator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-syntax-of-parols-grammar-description"><a class="header" href="#the-syntax-of-parols-grammar-description">The syntax of <code>parol</code>'s Grammar description</a></h1>
<p>Here I provide the definition of the PAR grammar in EBNF.</p>
<pre><code class="language-ebnf">(* PAR Grammar defined in EBNF *)
Parol               = Prolog GrammarDefinition.         (* The start symbol of the PAR grammar *)
Prolog              = StartDeclaration {Declaration} {ScannerState}.
StartDeclaration    = '%start' Identifier.
Declaration         = '%title' String
                    | '%comment' String
                    | &quot;%user_type&quot; Identifier '=' UserTypeName  (* User type alias definition *)
                    | ScannerDirectives.
ScannerDirectives   = '%line_comment' String
                    | '%block_comment' String String
                    | '%auto_newline_off'
                    | '%auto_ws_off'.
GrammarDefinition   = '%%' Production {Production}.     (* There must be at least one production - with the start symbol *)
Production          = Identifier ':' Alternations ';'.
Alternations        = Alternation {'|' Alternation}.
Alternation         = {Factor}.
Factor              = Group
                    | Repeat
                    | Optional
                    | Symbol.
Symbol              = NonTerminal                       (* EBNF: Meta-identifier *)
                    | SimpleToken
                    | TokenWithStates
                    | ScannerSwitch.                    (* Instruction to switch to new scanner state *)
SimpleToken         = String [ASTControl].              (* EBNF: Terminal-string, always treated as a regular expression! *)
TokenWithStates     = &quot;&lt;&quot; StateList &quot;&gt;&quot; String [ASTControl].
Group               = '(' Alternations ')'.             (* A non-empty grouping *)
Optional            = '[' Alternations ']'.             (* A non-empty optional expression *)
Repeat              = '{' Alternations '}'.             (* A non-empty repetition *)
NonTerminal         = Identifier [ASTControl].
Identifier          = '[a-zA-Z_]\w*'.
String              = '\u{0022}([^\\]|\\.)*?\u{0022}'.
ScannerState        = '%scanner' Identifier '{' {ScannerDirectives} '}'.
StateList           = Identifier { ',' Identifier }.    (* Scanner states a terminal symbol is associated with *)
ScannerSwitch       = '%sc' '(' [Identifier] ')'        (* Missing identifier implies INITIAL state *)
                    | '%push' '(' Identifier ')'        (* Identifier of scanner state is mandatory *)
                    | '%pop' '(' ')'.                   (* Parentheses are also mandatory *)
ASTControl          = CutOperator | UserTypeDeclaration.
CutOperator         = '^'.                              (* Prevents the symbol from being propagated to the AST in auto-gen *)
UserTypeDeclaration = ':' UserTypeName.                 (* Assigns the user type to a symbol *)
UserTypeName        = Identifier { '::' Identifier }.   (* A valid Rust qualified name *)
</code></pre>
<p>This grammar is quite concise and most programmers should be familiar with it. But there are several
specialties which will be described here. First please notice the built-in support for language
comments.</p>
<p>Using the <code>%line_comment</code> and <code>%block_comment</code> constructs you can easily define your language's
comments. For example you can define comments like it's done in the calc example
<code>calc.par</code>:</p>
<pre><code class="language-parol">%line_comment &quot;//&quot;
%block_comment  &quot;/\*&quot; &quot;\*/&quot;
</code></pre>
<p>You can supply more than one of these two comment declarations. They will all be considered as valid
comments.</p>
<p>As opposed to EBNF you use C-like line comments starting with two slashes (//) and bock comments
(/* ... */) in PAR files. This is a result of the close relationship between PAR grammar and
bison's grammar.</p>
<h2 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case sensitivity</a></h2>
<p>Non-terminals are treated case sensitive, i. e. &quot;list&quot; and &quot;List&quot; are different symbols. But it is
not encouraged to rely on this in your grammar definition. It is much better to keep a consistent
style on casing in your description.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p><code>parols</code>'s input language consists of two sections divided by the <code>%%</code> token. Above there are
declarations of which only the first <code>%start</code> declaration is mandatory. It declares the start symbol
of your grammar.
The second section below the <code>%%</code> token contains the actual grammar description in form of several
productions. At least one production must exist.</p>
<h2 id="the-start-symbol"><a class="header" href="#the-start-symbol">The start symbol</a></h2>
<p>It is important to note that the start symbol of the grammar must always be declared with the
<code>%start</code> declaration. It is the very first declaration in the PAR file.</p>
<pre><code class="language-parol">%start Grammar
</code></pre>
<h2 id="scanner-control"><a class="header" href="#scanner-control">Scanner control</a></h2>
<!-- markdownlint-disable no-inline-html -->
<p>A scanner (aka lexer) is automatically created from all used terminal symbols. Terminal symbols can
also be associated with different scanner states. See section
<a href="#scanner-states">Scanner states</a> below for more details.</p>
<!-- markdownlint-enable no-inline-html -->
<h3 id="newline-handling"><a class="header" href="#newline-handling">Newline handling</a></h3>
<p>The scanner per default skips newlines automatically. To suppress this use the <code>%auto_newline_off</code>
directive.
With this you have to handle newline tokens on your own in your grammar.</p>
<h3 id="whitespace-handling"><a class="header" href="#whitespace-handling">Whitespace handling</a></h3>
<p>The scanner also per default skips whitespace automatically. To suppress this use the <code>%auto_ws_off</code>
directive.
With this you have to handle whitespace tokens on your own in your grammar.</p>
<h3 id="terminal-name-generation"><a class="header" href="#terminal-name-generation">Terminal name generation</a></h3>
<p>The names of the terminals are deduced from the content of the terminal itself. For instance, for a
terminal &quot;:=&quot; it creates the terminal name &quot;ColonEqu&quot;, see generated parser for Oberon-0. If you
want this name to be more expressive, you can dedicate a separate production to the terminal, lets
say:</p>
<pre><code class="language-parol">Assign: &quot;:=&quot;;
</code></pre>
<p>With this trick you define a so called &quot;primary non-terminal for a terminal&quot; (I coined it this way)
that instructs the name generation to name the terminal &quot;Assign&quot;.</p>
<h3 id="terminal-conflicts"><a class="header" href="#terminal-conflicts">Terminal conflicts</a></h3>
<p>Since <code>parol</code> creates a scanner on the basis of the Rust regex crate all terminals are treated as if
they were regular expressions.
Thus you have to consider the following caveats.</p>
<ul>
<li>If you want to use a character that is a regex meta-character you have to escape it, like the '+'
in the following example:</li>
</ul>
<pre><code class="language-parol">AddOperator: &quot;\+|-&quot;;
</code></pre>
<ul>
<li>In case of conflicts between different terminals <em>the first seen will win</em></li>
</ul>
<p>The last point needs a more detailed explanation.
It's best to show an example for such a situation.
Say you have two terminals &quot;-&quot; and &quot;--&quot;, <em>minus</em> and <em>decrement</em>. The generated scanner is then
based on the following regular expression:</p>
<pre><code class="language-parol">    &quot;-|--&quot;
</code></pre>
<p>The Rust regex will now match two times <em>minus</em> when actually a <em>decrement</em> operator should be
detected.
It behaves here differently than a classic scanner/lexer like Lex that obeys the <em>longest match</em>
strategy.</p>
<p>Fortunately there is a simple way to achieve what we want. We just need a resulting regular
expression with a different order:</p>
<pre><code class="language-parol">    &quot;--|-&quot;
</code></pre>
<p>This will perfectly do the job.</p>
<p>To get such an order the <em>decrement</em> terminal has to be defined <strong>before</strong> the <em>minus</em> terminal as
in the following snippet.</p>
<pre><code class="language-parol">decrement: &quot;--&quot;
;
...
minus: &quot;-&quot;
;
</code></pre>
<p>Thats all.</p>
<p>With this simple but effective means you have the control over terminal conflicts.</p>
<h3 id="terminals-that-matches-an-empty-string"><a class="header" href="#terminals-that-matches-an-empty-string">Terminals that matches an empty string</a></h3>
<p>Please note that terminals should always match non-empty text portions. This means that you have to
avoid terminals like this:</p>
<pre><code class="language-parol">&quot;a?&quot;, &quot;a*&quot;, &quot;\b&quot;
</code></pre>
<p>Internally the tokenizer will enter a loop and match the empty string over and over again without
making progress in the input. Currently there is no check for this scenario in <code>parol_runtime</code>.</p>
<!-- markdownlint-disable no-inline-html -->
<h2 id=scanner-states>Scanner states</h2>
<!-- markdownlint-enable no-inline-html -->
<p>Additionally, <em>as of version <code>v0.2.0</code></em> the grammar supports <strong>multiple scanner states</strong>. This
feature is known from Flex as
<a href="https://www.cs.princeton.edu/~appel/modern/c/software/flex/flex_toc.html#TOC11">Start conditions</a>
and provides more flexibility in defining several scanners for several parts of your grammar. In
contrast to Flex the scanner state switching is defined directly within your grammar description and
not in semantic actions. This decision is made to foster the principle of strict separation of
grammar description and grammar processing in semantic actions.</p>
<h3 id="the-default-scanner-state-initial"><a class="header" href="#the-default-scanner-state-initial">The Default scanner state INITIAL</a></h3>
<p>INITIAL is the name of the default scanner state 0. Its behavior is defined with <code>ScannerDirectives</code>
in the global <code>Declaration</code> section, such as:</p>
<pre><code class="language-parol">%line_comment &quot;//&quot;
%block_comment &quot;/\*&quot; &quot;\*/&quot;
</code></pre>
<h3 id="introduce-new-scanner-states-with-the-scanner-directive"><a class="header" href="#introduce-new-scanner-states-with-the-scanner-directive">Introduce new scanner states with the %scanner directive</a></h3>
<p>Use the <code>%scanner Name {...}</code> construct after the global <code>Declaration</code> section and before the <code>%%</code>
sign to introduce arbitrary scanner states. The identifier following the %scanner token defines the
name of the state which is used to refer to it from scanner state lists at terminals.</p>
<pre><code class="language-parol">%scanner String {
    %auto_newline_off
    %auto_ws_off
}

%scanner Pragma {
    %block_comment &quot;\{&quot; &quot;\}&quot;
}
</code></pre>
<p>You can place any of the <code>ScannerDirectives</code> within the block that defines the scanner state.</p>
<p>By default each scanner handles (and skips) whitespace and newlines. Use <code>%auto_newline_off</code> and
<code>%auto_ws_off</code> to modify each scanner state appropriately.</p>
<p>Associate terminals with scanner states by prefixing them with a list of comma separated state names
in angle brackets. Like this:</p>
<pre><code class="language-parol">StringDelimiter
    : &lt;String, INITIAL&gt;&quot;\u{22}&quot;
    ;
</code></pre>
<p>Scanner state references in different occurrences of the same terminal are accumulated. I.e.,</p>
<pre><code class="language-parol">&lt;State1&gt;&quot;term&quot;
...
&lt;State2&gt;&quot;term&quot;
</code></pre>
<p>will result in</p>
<pre><code class="language-parol">&lt;State1, State2&gt;&quot;term&quot;
</code></pre>
<p>Terminals without explicitly associated scanner state are implicitly associated with scanner state
INITIAL.</p>
<p>Scanner state switching is initiated within your productions like in the following two examples:</p>
<pre><code class="language-parol">String: StringDelimiter %sc(String) StringContent StringDelimiter %sc();

</code></pre>
<p>or</p>
<pre><code class="language-parol">String: StringDelimiter %push(String) StringContent StringDelimiter %pop();

</code></pre>
<p>The <code>%sc</code> instruction is used to switch directly to the state named in the parentheses. The INITIAL
state can be omitted as seen in the second occurrence of the first example, i.e. <code>%sc()</code> and
<code>%sc(INITIAL)</code> are equivalent.</p>
<p>The <code>%push</code> instruction is used to push the index of the current scanner on the internal scanner
stack and to switch to a scanner configuration with the given index in parentheses.</p>
<p>The <code>%pop</code> instruction is used to pop the index of the scanner pushed before and to switch to the
scanner configuration with that index.</p>
<blockquote>
<p>Currently the scanner state switching only works if the lookahead
<strong>at the point where the switch is made</strong> is only of size 1 because the lookahead mechanism is not
aware of scanner states. This means the provision of lookahead tokens will be made with the current
active scanner and may fail if a token is not known by it. In most cases this can be circumvented by
an appropriate grammar formulation.</p>
<p>If the scanner switch was successful the lookahead buffer is invalidated.</p>
</blockquote>
<p>You may have look at example <code>scanner_states</code> that demonstrates the handling of scanner states.</p>
<h2 id="omitting-grammar-symbol-from-the-ast-in-auto-gen-modus"><a class="header" href="#omitting-grammar-symbol-from-the-ast-in-auto-gen-modus">Omitting grammar symbol from the AST in auto-gen modus</a></h2>
<p>You can suffix grammar symbols (terminals and non-terminals) with a cut operator (^). This instructs
<code>parol</code> to not propagate them to the AST in auto-gen modus.</p>
<pre><code class="language-parol">Group: &quot;\(&quot;^ Alternations &quot;\)&quot;^;
</code></pre>
<p>The AST type for the symbol <code>Group</code> will then only contain a member for the non-terminal
<code>Alternations</code>. The parentheses are ignored.</p>
<h2 id="assigning-user-types-to-grammar-symbols"><a class="header" href="#assigning-user-types-to-grammar-symbols">Assigning user types to grammar symbols</a></h2>
<p>You can specify a user type to be inserted into the AST structure at the place where the symbol
would otherwise had the originally generated type.
Add after a grammar symbol a colon followed by a user type name to instruct <code>parol</code> to use this type
instead. In your language implementation you have to provide fallible or infallible conversions
from the original generated types to your types by implementing one of the traits <code>From</code> or <code>TryFrom</code>.
An examples can be found in the <code>list_auto</code> example.
You can also define aliases for the user type names by inserting as many <code>%user_type</code> directives as
you want. Then use these aliases behind the colons.</p>
<h2 id="semantic-actions"><a class="header" href="#semantic-actions">Semantic actions</a></h2>
<p>Semantic actions are strictly separated from your grammar description.
You will use a generated trait with default implementations for each production of your grammar. You
can implement this trait in your grammar processing item and provide concrete implementations for
those productions you are interested in.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="GettingStarted.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="OperatorPrecedence.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="GettingStarted.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="OperatorPrecedence.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
