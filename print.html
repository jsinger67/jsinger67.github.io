<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Parol Parser Generator</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Parol Parser Generator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- markdownlint-disable first-line-h1 -->
<!-- markdownlint-disable Inline HTML -->
<br>
<img src="./Parol.svg" alt="Logo" height="150" width="150">
<br><br><br>
<!-- markdownlint-enable Inline HTML -->
<!-- markdownlint-enable first-line-h1 -->
<h1 id="the-parol-parser-generator"><a class="header" href="#the-parol-parser-generator">The <code>parol</code> Parser Generator</a></h1>
<p><a href="https://github.com/jsinger67/parol"><code>parol</code></a> is a parser generator with unique features.</p>
<p>It is available as a command-line tool that generates complete parsers from a single grammar
description file. <code>parol</code> is also a library you can use in your own crates.</p>
<p>With its builder API, you can easily integrate code generation into your crate's build process via a
Cargo build script (<code>build.rs</code>).</p>
<p><code>parol</code> automatically infers and generates all AST data types by analyzing your language's grammar
description.</p>
<p>You can control AST type generation in several ways:</p>
<ul>
<li>Mark elements to omit from your AST.</li>
<li>Specify custom types for language elements, which are inserted at the correct position in the
resulting AST type.</li>
<li>Define how each symbol on the right-hand side of a production is named in the generated structure.</li>
</ul>
<p>Language description and implementation are strictly separated in <code>parol</code>. You can design your
grammar without processing anything, as generated parsers function by default as acceptors. This
enables <strong>rapid prototyping</strong> of your grammar.</p>
<p><code>parol</code> generates a trait that serves as the interface between the generated parser and your
language processing. The trait contains functions for each non-terminal in your grammar, which you
can implement as needed. In the simplest case, you implement the trait function for the start symbol,
which is called after the entire input string is parsed. This function receives a parameter
representing the complete structure of the parsed document.</p>
<p>The parser automatically calls the interface trait's functions via a separately generated adapter
during parsing.</p>
<p><code>parol</code> provides an ecosystem of tools, including a
<a href="https://github.com/jsinger67/parol/tree/main/tools/parol-vscode">Visual Studio Code Extension</a> and
a <a href="https://github.com/jsinger67/parol/tree/main/crates/parol-ls">Language Server</a>.</p>
<p>Generated parsers can recover from syntax errors automatically. This means the parser does not stop
parsing after the first syntax error, but instead tries to synchronize with the input and continue
analysis.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="history-of-this-project"><a class="header" href="#history-of-this-project">History of This Project</a></h1>
<p>The <code>parol</code> parser generator began as a personal journey to master LL(k) parsing using deterministic
finite automata.</p>
<p>Two parser generators, with contrasting approaches, significantly influenced its design:</p>
<ul>
<li>The classic Unix tool Yacc and <a href="https://www.gnu.org/software/bison/">Bison</a></li>
<li><a href="https://www.antlr.org/">ANTLR</a></li>
</ul>
<p>Both have unique quirks and idiosyncrasies.</p>
<p>Bison often produces shift/reduce or reduce/reduce conflicts that can be difficult to understand.
ANTLR generates recursive descent parsers, which are prone to stack overflows. It is easy to write
(or generate) a program that crashes a parser generated by ANTLR. E.g., you can generate a deeply
nested expression with 6000 nested parenthesis.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<p>However, Bison generates deterministic parsers using finite automata, and ANTLR also uses
deterministic finite automata to select the next production for a non-terminal.</p>
<p>This led to the question: Why not combine the best of both worlds?</p>
<p>With this goal, I began my first attempts using F# (<a href="https://github.com/jsinger67/Lelek">Lelek</a>).
Eventually, I discontinued this project because it no longer felt right.</p>
<p>Lelek was a necessary step to understand what is feasible and what is not.</p>
<p>After several attempts, I transitioned to Rust, which felt more vibrant and compelling.</p>
<p>Thus, <code>parol</code> was born—initially as a rewrite of Lelek. I was willing to discard some parts of Lelek
and introduce new approaches.</p>
<h2 id="what-i-retained"><a class="header" href="#what-i-retained">What I Retained</a></h2>
<ul>
<li>The basic approach of using regexes to generate scanners</li>
<li>Using DFAs to solve the <a href="https://github.com/jsinger67/Lelek/blob/master/docs/Approach.md">Rule Decision Problem</a>, although I changed the method for obtaining k-sets for productions</li>
<li>The foundational ideas behind the grammar description language and its resemblance to Bison's
input format</li>
<li>The separation of language description and implementation</li>
<li>The strategy to check a grammar for preconditions before generating parser data, ensuring
termination of certain algorithms</li>
<li>The algorithm for <a href="https://github.com/jsinger67/id-tree-layout">visualizing parse trees</a></li>
</ul>
<h2 id="what-i-changed"><a class="header" href="#what-i-changed">What I Changed</a></h2>
<ul>
<li>Recursion detection</li>
<li>Generation of k-sets for productions (including algorithms for FIRST(k) and FOLLOW(k))</li>
<li>Terminology: I now prefer 'Production' over 'Rule'</li>
<li>The <a href="https://github.com/jsinger67/parol_runtime">parser runtime</a> was separated into a small crate</li>
</ul>
<h2 id="what-i-added"><a class="header" href="#what-i-added">What I Added</a></h2>
<ul>
<li>Automatic inference and generation of all types for the grammar's AST, making the grammar description sufficient for <code>parol</code> to build a fully functional acceptor with no extra effort—enabling <strong>real rapid prototyping</strong> for your language!</li>
<li>Built-in tools for:
<ul>
<li>Generating new crates</li>
<li>Checking a grammar for properties (left-recursion, reachability, productivity)</li>
<li>Left-factoring a grammar</li>
<li>Calculating FIRST(k) and FOLLOW(k) sets</li>
<li>Generating random sentences from a grammar description</li>
</ul>
</li>
<li>Scanner states, also known as <a href="https://www.cs.princeton.edu/~appel/modern/c/software/flex/flex_toc.html#TOC11">start conditions</a></li>
<li>Build script integration to invoke <code>parol</code> automatically during your crate's build process</li>
<li>A <a href="https://github.com/jsinger67/parol/tree/main/tools/parol-vscode">Visual Studio Code extension</a> and a <a href="https://github.com/jsinger67/parol/tree/main/crates/parol-ls">Language Server</a></li>
<li>Optional support for LALR(1) grammars in addition to LL(k)</li>
<li>Features that Lelek never received</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>To be fair, parol is not immune from stack overflows. In deeply nested expressions the built
up data structures become deeply nested as well. Some compiler-generated trait implementations like
<code>Clone</code> or <code>Drop</code> the can then also create stack overflows. But this can be circumvented by
carefully implementing such traits on your own. <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Before you can use <code>parol</code>, you need to install it.</p>
<p>Since <code>parol</code> generates Rust code, a Rust toolchain must be installed. If you do not have Rust,
visit <a href="https://rustup.rs/">Rustup</a> or <a href="https://www.rust-lang.org/tools/install">Install Rust</a>.</p>
<p><code>parol</code> requires only stable Rust.</p>
<p>To install <code>parol</code> on your platform, run:</p>
<pre><code class="language-shell">cargo install parol
</code></pre>
<p>To verify the installation, execute:</p>
<pre><code class="language-shell">parol -V
parol 4.0.1
</code></pre>
<p>If you see an error indicating the tool could not be found, check your PATH variable. It should
include <code>~/.cargo/bin</code>.</p>
<h3 id="video-introduction"><a class="header" href="#video-introduction">Video Introduction</a></h3>
<p>For a visual introduction, watch the <a href="https://youtu.be/TJMwMqD4XSo">introductory video</a> on YouTube.</p>
<h2 id="generate-a-crate-with-parol"><a class="header" href="#generate-a-crate-with-parol">Generate a Crate with <code>parol</code></a></h2>
<p>Use the <code>parol new</code> subcommand to create a new project:</p>
<pre><code class="language-shell">parol new --bin --path ./my_grammar
</code></pre>
<p>Change into the new project folder and start the initial build. <code>parol</code> will generate two files from
the initial grammar definition.</p>
<pre><code class="language-shell">cd ./my_grammar
cargo build
</code></pre>
<blockquote>
<p>You can safely ignore the <code>#[warn(unused_imports)]</code> warning for now. It will disappear as the
grammar receives more content.</p>
</blockquote>
<p>Run the test with the generated parser:</p>
<pre><code class="language-shell">cargo run ./test.txt
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.87s
     Running `target\debug\my_grammar.exe ./test.txt`
Parsing took 0 milliseconds.
Success!
MyGrammar { my_grammar: Token { text: "Hello world!", token_type: 5, location: Location {
start_line: 4, start_column: 5, end_line: 4, end_column: 17, start: 62, end: 74, file_name:
"./test.txt" }, token_number: 2 } }
</code></pre>
<p><code>parol</code> has generated a complete parser with AST types suitable for your grammar description.</p>
<p>Now, open your preferred editor:</p>
<pre><code class="language-shell">code .
</code></pre>
<p>Edit the grammar description in <code>my_grammar.par</code> to fit your requirements. Any subsequent invocation
of <code>cargo build</code> will trigger <code>parol</code> to regenerate the derived sources automatically if
<code>my_grammar.par</code> has changed.</p>
<p><strong>This is all you need to set up a working development environment.</strong></p>
<blockquote>
<h2 id="vs-code-extension-and-language-server"><a class="header" href="#vs-code-extension-and-language-server">VS Code Extension and Language Server</a></h2>
<p>A VS Code extension, <a href="https://github.com/jsinger67/parol/tree/main/tools/parol-vscode">parol-vscode</a>,
is available.</p>
<p>Install this extension from the VS Code
<a href="https://marketplace.visualstudio.com/items?itemName=jsinger67.parol-vscode">Marketplace</a>.
It provides syntax highlighting, folding, and language icons, which will be useful for you.</p>
<p>The extension utilizes a
<a href="https://github.com/jsinger67/parol/tree/main/crates/parol-ls">Language Server</a> that must be
installed separately.</p>
<pre><code class="language-shell">cargo install --force parol-ls
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-syntax-of-parols-grammar-description"><a class="header" href="#the-syntax-of-parols-grammar-description">The syntax of <code>parol</code>'s Grammar description</a></h1>
<p>I provide the definition of the PAR grammar in PAR grammar <a href="https://github.com/jsinger67/parol/blob/main/crates/parol/src/parser/parol.par">itself</a>.</p>
<p>This grammar is quite concise and most programmers should be familiar with it. But there are several
specialties which will be described here. First please notice the built-in support for language
comments.</p>
<p>Using the <code>%line_comment</code> and <code>%block_comment</code> constructs you can easily define your language's
comments. For example you can define comments like it's done in the calc example
<code>calc.par</code>:</p>
<pre><code class="language-parol">%line_comment "//"
%block_comment  "/\*" "\*/"
</code></pre>
<p>You can supply more than one of these two comment declarations. They will all be considered as valid
comments.</p>
<p>As opposed to EBNF you use C-like line comments starting with two slashes (//) and bock comments
(/* ... */) in PAR files. This is a result of the close relationship between PAR grammar and
bison's grammar.</p>
<p><code>parol</code> doesn't simply discard language comments. They are provided during
parse process via a new method <code>&lt;UserType&gt;GrammarTrait::on_comment</code> which is called for each
single comment in order of their appearance each time before the parser consumes a normal token from
token stream.
The method is default implemented and the user have to provide an own implementation if she is
interested in language comments.</p>
<p>This is a minimal support but can greatly improve the usability.</p>
<h2 id="defining-the-grammar-type"><a class="header" href="#defining-the-grammar-type">Defining the grammar type</a></h2>
<p>In the global header section you can define the grammar type you want to use in your grammar
description.</p>
<p>The default grammar type is LL(k) and can be omitted.</p>
<pre><code class="language-parol">%grammar_type 'LL(k)'
</code></pre>
<p>You have the option to use LALR(1) grammar type this way.</p>
<pre><code class="language-parol">%grammar_type 'LALR(1)'
</code></pre>
<h2 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case sensitivity</a></h2>
<p>Non-terminals are treated case sensitive, i. e. "list" and "List" are different symbols. But it is
not encouraged to rely on this in your grammar definition. It is much better to keep a consistent
style on casing in your description.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p><code>parols</code>'s input language consists of two sections divided by the <code>%%</code> token. Above there are
declarations of which only the first <code>%start</code> declaration is mandatory. It declares the start symbol
of your grammar.
The second section below the <code>%%</code> token contains the actual grammar description in form of several
productions. At least one production must exist.</p>
<h2 id="the-start-symbol"><a class="header" href="#the-start-symbol">The start symbol</a></h2>
<p>It is important to note that the start symbol of the grammar must always be declared with the
<code>%start</code> declaration. It is the very first declaration in the PAR file.</p>
<pre><code class="language-parol">%start Grammar
</code></pre>
<h2 id="scanner-control"><a class="header" href="#scanner-control">Scanner control</a></h2>
<!-- markdownlint-disable no-inline-html -->
<p>A scanner (aka lexer) is automatically created from all used terminal symbols. Terminal symbols can
also be associated with different scanner states. See section
<a href="ParGrammar.html#scanner-states">Scanner states</a> below for more details.</p>
<!-- markdownlint-enable no-inline-html -->
<h3 id="newline-handling"><a class="header" href="#newline-handling">Newline handling</a></h3>
<p>The scanner per default skips newlines automatically. To suppress this use the <code>%auto_newline_off</code>
directive.
With this you have to handle newline tokens on your own in your grammar.</p>
<h3 id="whitespace-handling"><a class="header" href="#whitespace-handling">Whitespace handling</a></h3>
<p>The scanner also per default skips whitespace automatically. To suppress this use the <code>%auto_ws_off</code>
directive.
With this you have to handle whitespace tokens on your own in your grammar.</p>
<h3 id="terminal-name-generation"><a class="header" href="#terminal-name-generation">Terminal name generation</a></h3>
<p>The names of the terminals are deduced from the content of the terminal itself. For instance, for a
terminal ":=" it creates the terminal name "ColonEqu", see generated parser for Oberon-0. If you
want this name to be more expressive, you can dedicate a separate production to the terminal, lets
say:</p>
<pre><code class="language-parol">Assign: ":=";
</code></pre>
<p>With this trick you define a so called "primary non-terminal for a terminal" (I coined it this way)
that instructs the name generation to name the terminal "Assign".</p>
<h3 id="terminal-representation"><a class="header" href="#terminal-representation">Terminal representation</a></h3>
<p><code>parol</code> supports three different styles of terminal representations, all of them being valid and
allowed.</p>
<ul>
<li>The <strong>string syntax</strong> (<code>"..."</code>). These terminals are treated as if they were <strong>regular expressions.</strong></li>
<li>The <strong>single quoted</strong> string literals (<code>'..'</code>) are <strong>literals or raw strings</strong>. The user doesn't
need to escape any regex meta character. This is used when you don't want to deal with regexes and
only use plain text. E.g.: <code>BlockBegin: '{'</code></li>
<li>The <strong>regular expression strings</strong> (<code>/../</code>), behaves exactly like the double quoted string, i.e.
they are treated as <strong>regular expressions</strong> but this style better conveys the intent. E.g.:
<code>Digits: /[\d]+/;</code></li>
</ul>
<p>Internally <code>parol</code> creates scanners on the basis of the <code>scnr2</code> crate and all terminals are
expressed as regular expressions eventually. You should be aware of this if you get strange errors
from regex generation and want to understand the problem.</p>
<p>Here is an example for a terminal in regular expression form:</p>
<pre><code class="language-parol">AddOperator: /\+|-/;
</code></pre>
<h3 id="terminal-conflicts"><a class="header" href="#terminal-conflicts">Terminal conflicts</a></h3>
<ul>
<li>Parol's scanner follows the longest match rule</li>
<li>Conflicts can only occur, if the matched tokens have the same length and are accepted by more than
one terminal type. In case of such a conflict between different terminals, terminals defined earlier
in the grammar have higher priority than those defined later. This allows you to influence the
priority of tokens with equal length. In all other cases, tokens with the longest match are
preferred.</li>
</ul>
<p>For example, if you have two terminals "-" and "--", <em>Minus</em> and <em>Decr</em>, the scanner will match
based on the longest match basis:</p>
<pre><code class="language-parol">Decr: /--/
    ;

Minus
    : /-/
    ;

</code></pre>
<p>An input string <code>-----</code> will match the decrement operator twice and then the minus operator once.</p>
<p>As an example for tokens with the same length consider following terminal definitions:</p>
<pre><code class="language-parol">// ❌
Ident: /[a-zA-Z_][a-zA-Z0-9_]*/
    ;

If: 'if'
    ;
</code></pre>
<p>In case of same length, the scanner will match based on the order of definition:</p>
<p>On input <code>if</code> it will match the <code>Ident</code> first. To make this work you have to move the terminal <code>If</code>
before the more general <code>Ident</code>:</p>
<pre><code class="language-parol">// ✅
If: 'if'
    ;

Ident: /[a-zA-Z_][a-zA-Z0-9_]*/
    ;
</code></pre>
<p>Defining <em>If</em> before <em>Ident</em> ensures the correct priority.</p>
<h4 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h4>
<p>❗ These two mechanisms, <strong>longest match rule</strong> and <strong>priority by order</strong>, gives you control over
terminal conflicts.</p>
<h3 id="terminals-that-matches-an-empty-string"><a class="header" href="#terminals-that-matches-an-empty-string">Terminals that matches an empty string</a></h3>
<p>Please note that terminals should always match non-empty text portions. This means that you have to
avoid terminals like this:</p>
<pre><code class="language-parol">/a?/, /a*/
</code></pre>
<p>Internally the tokenizer will enter a loop and match the empty string over and over again without
making progress in the input. Currently there is no check for this scenario in <code>parol_runtime</code>.</p>
<p>There is a <strong>workaround</strong> when you simply need possibly empty tokens, at least for the <code>?</code> and <code>*</code>
ones.
Make the token <code>+</code> and put their uses in optional expressions <code>[]</code>. This makes them non-empty and
also their possible emptiness explicit for the grammar:</p>
<pre><code class="language-parol">RuleWithWhiteSpaces: WhiteSpaces;
WhiteSpaces: /[ \t]*/;

// =&gt;

RuleWithWhiteSpaces: [ WhiteSpaces ];
WhiteSpaces: /[ \t]+/;
</code></pre>
<!-- markdownlint-disable no-inline-html -->
<h2 id=scanner-states>Scanner states</h2>
<!-- markdownlint-enable no-inline-html -->
<p><code>Parol</code> supports <strong>multiple scanner states</strong>. This feature is known from Flex as
<a href="https://www.cs.princeton.edu/~appel/modern/c/software/flex/flex_toc.html#TOC11">Start conditions</a>
and provides more flexibility in defining several scanners for several parts of your grammar.</p>
<p><code>Parol</code> provides two different ways to control scanner states directly within your grammar
description thereby holding the principle of strict separation of grammar description and grammar
processing in semantic actions. This means no scanner switching in your code, but in the grammar
description. Only because of this rapid prototyping is possible.</p>
<h3 id="the-default-scanner-state-initial"><a class="header" href="#the-default-scanner-state-initial">The Default scanner state INITIAL</a></h3>
<p>INITIAL is the name of the default scanner state 0. Its behavior is defined with <code>ScannerDirectives</code>
in the global <code>Declaration</code> section, such as:</p>
<pre><code class="language-parol">%line_comment "//"
%block_comment "/\*" "\*/"
</code></pre>
<h3 id="introduce-new-scanner-states-with-the-scanner-directive"><a class="header" href="#introduce-new-scanner-states-with-the-scanner-directive">Introduce new scanner states with the %scanner directive</a></h3>
<p>Use the <code>%scanner Name {...}</code> construct after the global <code>Declaration</code> section and before the <code>%%</code>
sign to introduce arbitrary scanner states. The identifier following the %scanner token defines the
name of the state which is used to refer to it from scanner state lists at terminals.</p>
<pre><code class="language-parol">%scanner String {
    %auto_newline_off
    %auto_ws_off
}

%scanner Pragma {
    %block_comment "\{" "\}"
}
</code></pre>
<p>You can place any of the <code>ScannerDirectives</code> within the block that defines the scanner state.</p>
<p>By default each scanner handles (and skips) whitespace and newlines. Use <code>%auto_newline_off</code> and
<code>%auto_ws_off</code> to modify each scanner state appropriately.</p>
<p>Associate terminals with scanner states by prefixing them with a list of comma separated state names
in angle brackets. Like this:</p>
<pre><code class="language-parol">StringDelimiter
    : &lt;String, INITIAL&gt;/"/
    ;
</code></pre>
<p>Scanner state references in different occurrences of the same terminal are accumulated. I.e.,</p>
<pre><code class="language-parol">&lt;State1&gt;"term"
...
&lt;State2&gt;"term"
</code></pre>
<p>will result in</p>
<pre><code class="language-parol">&lt;State1, State2&gt;"term"
</code></pre>
<p>Terminals without explicitly associated scanner state are implicitly associated with scanner state
INITIAL.</p>
<h3 id="scanner-switching"><a class="header" href="#scanner-switching">Scanner switching</a></h3>
<p>Scanner-based scanner switching in Parol is managed by the scanner using the <code>%enter</code>, <code>%push</code>, and
<code>%pop</code> directives within the scanner specification:</p>
<ul>
<li><code>%enter</code>: Switches the scanner to a specific mode, replacing the current mode.</li>
<li><code>%push</code>: Pushes the current mode onto a stack and enters a new mode.</li>
<li><code>%pop</code>: Returns to the previous mode by popping the mode stack.</li>
</ul>
<p>These directives ensure that scanner mode switching is handled consistently and reliably, preventing
token buffer desynchronization in LL(k) grammars with k &gt; 1. All scanner-related features are based
on the <a href="https://crates.io/crates/scnr2"><code>scnr2</code></a> crate.</p>
<p>Example usage:</p>
<pre><code class="language-parol">%on Rem %enter Cmnt
%on If, AssignOp, Print %enter Expr

%scanner Cmnt {
    %auto_newline_off
    %on EndOfLine %enter INITIAL
}
%scanner Expr {
    %auto_newline_off
    %on Then, Goto, EndOfLine %enter INITIAL
}
</code></pre>
<p>After the <code>%on</code> directive, specify a list of primary non-terminals. After the <code>%enter</code> directive,
specify the target scanner state. <code>%push</code> and <code>%pop</code> provide stack-based mode management.</p>
<p>Mixing parser-based and scanner-based switching in one grammar file is not allowed and will result
in errors.</p>
<p>Parol generates all data required by <code>scnr2</code> to construct valid and efficient scanners. Users do not
need to understand the internal configuration of <code>scnr2</code>.</p>
<h2 id="controlling-the-ast-generation"><a class="header" href="#controlling-the-ast-generation">Controlling the AST generation</a></h2>
<h3 id="omitting-grammar-symbols-from-the-ast"><a class="header" href="#omitting-grammar-symbols-from-the-ast">Omitting grammar symbols from the AST</a></h3>
<p>You can suffix grammar symbols (terminals and non-terminals) with a cut operator (<code>^</code>). This
instructs <code>parol</code> to not propagate them to the AST.</p>
<pre><code class="language-parol">Group: '('^ Alternations ')'^;
</code></pre>
<p>The AST type for the symbol <code>Group</code> will then only contain a member for the non-terminal
<code>Alternations</code>. The parentheses are left out.</p>
<h3 id="assigning-user-types-to-grammar-symbols"><a class="header" href="#assigning-user-types-to-grammar-symbols">Assigning user types to grammar symbols</a></h3>
<p>You can specify a user type to be inserted into the AST structure at the place where the symbol
would otherwise had the originally generated type.
Add after a grammar symbol a colon followed by a user type name to instruct <code>parol</code> to use this type
instead. In your language implementation you have to provide fallible conversions from references of
the original generated types (<code>&amp;T</code>) to your types (<code>U</code>) by implementing the trait
<code>TryFrom&lt;&amp;T&gt; for U</code>.</p>
<p>An examples can be found in the <code>list</code> example.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'t&gt; TryFrom&lt;&amp;Token&lt;'t&gt;&gt; for Number {
    type Error = anyhow::Error;

    fn try_from(number: &amp;Token&lt;'t&gt;) -&gt; std::result::Result&lt;Self, Self::Error&gt; {
        Ok(Self(number.text().parse::&lt;u32&gt;()?))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can also define aliases for the user type names by inserting as many <code>%user_type</code> directives as
you want.</p>
<pre><code class="language-parol">%user_type Number = crate::list_grammar::Number
</code></pre>
<p>Then use these aliases behind the colons.</p>
<pre><code class="language-parol">Num: "0|[1-9][0-9]*": Number;
</code></pre>
<h3 id="define-user-types-for-non-terminals"><a class="header" href="#define-user-types-for-non-terminals">Define user types for non-terminals</a></h3>
<p>As of version 3.0 you can easily define a user type to which each occurrence of a certain
non-terminal should be automatically converted to.
This is done like in the following example:</p>
<pre><code class="language-ebnf">%nt_type ScannerState = crate::parser::parol_grammar::ScannerConfig
</code></pre>
<p>It is similar to the already available <code>%user_type</code> with what you could define an alias for a
user defined type which in turn you could apply to single symbols on the right-hand side of
grammar productions. The <code>%nt_type</code> can't be used on terminals but it makes the application to
non-terminals much easier.
Here is the old version used in <code>parol</code> itself before (only partial)</p>
<pre><code class="language-ebnf">%user_type ScannerConfig = crate::parser::parol_grammar::ScannerConfig
// ...
%%
// ...
Prolog
: StartDeclaration { Declaration } { ScannerState: ScannerConfig }
;
</code></pre>
<p>And here is the new variant in which <code>%nt_type</code> is used.</p>
<pre><code class="language-ebnf">%nt_type ScannerState = crate::parser::parol_grammar::ScannerConfig
// ...
%%
// ...
Prolog
: StartDeclaration { Declaration } { ScannerState }
;
</code></pre>
<p>The non-terminal <code>ScannerState</code> was automatically defined the be converted to <code>ScannerConfig</code>.</p>
<p>It is semantically completely identical to use <code>%user_type</code> and the application of it to each
occurrence of the non-terminal in the grammar explicitly.</p>
<h3 id="user-defined-terminal-type"><a class="header" href="#user-defined-terminal-type">User defined terminal type</a></h3>
<p>As of version 3.0 you can easily define a user type to which each occurrence of a terminal should be
automatically converted to.
This is done like in the following example:</p>
<pre><code class="language-ebnf">%t_type crate::parol_ls_grammar::OwnedToken
</code></pre>
<p>There can be only one type defined to which all terminals are converted to.</p>
<p>More specifically, if several such instructions are given, the last one wins.</p>
<p>Here is the old version used in <code>parol-ls</code> itself before (only partial)</p>
<pre><code class="language-ebnf">%user_type OwnedToken = crate::parol_ls_grammar::OwnedToken
// ...
%%
// ...
ScannerSwitch
    : "%sc": OwnedToken '(': OwnedToken [ Identifier ] ')': OwnedToken
    | "%push": OwnedToken '(': OwnedToken Identifier ')': OwnedToken
    | "%pop": OwnedToken '(': OwnedToken ')': OwnedToken
    ;
</code></pre>
<p>And here is the new variant in which <code>%t_type</code> is used.</p>
<pre><code class="language-ebnf">%t_type crate::parol_ls_grammar::OwnedToken
// ...
%%
// ...
ScannerSwitch
    : "%sc" '(' [ Identifier ] ')'
    | "%push" '(' Identifier ')'
    | "%pop" '(' ')'
    ;
</code></pre>
<p>All terminals are automatically defined the be converted to <code>crate::parol_ls_grammar::OwnedToken</code>.</p>
<h3 id="define-user-defined-member-names"><a class="header" href="#define-user-defined-member-names">Define user defined member names</a></h3>
<p>As of version 3.0 you can specify for each symbol on the right-hand side of a production how its
corresponding member in the generated struct should be named.</p>
<p>To achieve this you can use the newly introduced <code>@</code> operator.</p>
<pre><code class="language-parol">Declaration :
    ...
    | "%nt_type" Identifier@nt_name "="^ UserTypeName@nt_type
    ...
</code></pre>
<p>In this example the member for Identifier in the production will be named <code>nt_name</code> and the member
for UserTypeName will receive the name <code>nt_type</code> in the generated struct type for this production.</p>
<h2 id="semantic-actions"><a class="header" href="#semantic-actions">Semantic actions</a></h2>
<p>Semantic actions are strictly separated from your grammar description.
You will use a generated trait with default implementations for each non-terminal of your grammar.
You can implement this trait in your grammar processing item and provide concrete implementations
for those non-terminals you are interested in.</p>
<p>In the chapter <a href="./OperatorPrecedence.html">Operator Precedence</a> there are some examples on how to
implement simple semantic actions.</p>
<p>A separate chapter <a href="./SemanticActions.html">Semantic Actions</a> deals more deeply with this topic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-precedence"><a class="header" href="#operator-precedence">Operator Precedence</a></h1>
<p>Operator precedence is implemented through grammar definitions. By placing higher-priority elements
into sub-categories, you force the parser to branch into those first, resulting in earlier
evaluation.</p>
<p>Consider the following example:</p>
<pre><code class="language-parol">%start Precedence
%title "Operator precedence"
%comment "Shows the handling of operator precedence in `parol`"

%%

// ---------------------------------------------------------
// VARIABLE
Variable: /(?i)[A-Z][0-9A-Z]*/ ;
Literal : /[0-9]+/ ;

// ---------------------------------------------------------
// OPERATOR SYMBOLS
Plus    : '+' ;
Minus   : '-' ;
MulOp   : "\*|/" ;

// ---------------------------------------------------------
// PARENTHESIS
LParen  : '(' ;
RParen  : ')' ;

// ---------------------------------------------------------
// EXPRESSIONS in order of increasing precedence
Precedence      : Summation ;
Summation       : Multiplication { (Plus | Minus) Multiplication } ;
Multiplication  : Factor { MulOp Factor } ;
Factor          : Literal
                | Variable
                | Minus Factor
                | LParen Precedence RParen ;
</code></pre>
<p>Parsing the string <code>-1 + x * 5</code> with the generated parser produces the following parse tree:</p>
<p><img src="./precedence/test.svg" alt="Parse Tree" /></p>
<p>Notice that the innermost operator is evaluated first by the parser—here, the negation in the
<code>Factor</code> production.</p>
<p><code>Multiplication</code> is the second-highest priority in this example, as it is a sub-category of
<code>Summation</code>.</p>
<p>To try this grammar, run:</p>
<pre><code class="language-shell">parol new --bin --path .\precedence --tree
</code></pre>
<p>Replace the generated dummy grammar with the example above. Also, set <code>test.txt</code> to:</p>
<pre><code class="language-text">-1 + x * 5
</code></pre>
<p>Parse the text by running:</p>
<pre><code class="language-shell">cargo run ./test.txt
</code></pre>
<p>from the root of the generated crate.</p>
<p>Because the <code>--tree</code> flag was used with <code>parol new</code>, parse trees are generated automatically. Look
for a <code>test.svg</code> file next to <code>test.txt</code>.</p>
<p>It is recommended to use parse tree generation during grammar development and remove it when
deploying your parser in production.</p>
<p><em><strong>However, the parse tree can be useful in certain scenarios. Because it's lossless, it also
includes otherwise discarded tokens like spaces.</strong></em></p>
<h2 id="how-do-i-implement-the-grammar-processing"><a class="header" href="#how-do-i-implement-the-grammar-processing">How do I implement the grammar processing?</a></h2>
<p>You should have a look at the example <a href="https://github.com/jsinger67/parol/tree/main/examples/calc">calc</a>.</p>
<p>Basically, the grammar processing is implemented in the <code>calc_grammar.rs</code>.</p>
<p>The struct <code>CalcGrammar</code> contains a collection of variables and their values called <code>env</code>.
It also contains a stack of values that holds the intermediate results during the calculation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub calc_results: Vec&lt;DefinitionRange&gt;,
pub env: BTreeMap&lt;String, DefinitionRange&gt;,
<span class="boring">}</span></code></pre></pre>
<p>You can extend the struct <code>PrecedenceGrammar</code> in <code>src\precedence_grammar.rs</code> the same way.</p>
<p>Now you can implement selected semantic actions from the <code>PrecedenceGrammarTrait</code>. Look at the
generated <code>src\precedence_grammar_trait.rs</code>. It contains all available semantic actions which are
bound to non-terminals.</p>
<p>To implement for instance the <code>variable</code> action, copy the <code>fn variable...</code> block into the</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'t&gt; PrecedenceGrammarTrait&lt;'t&gt; for PrecedenceGrammar&lt;'t&gt; {

}
<span class="boring">}</span></code></pre></pre>
<p>This way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'t&gt; PrecedenceGrammarTrait&lt;'t&gt; for PrecedenceGrammar&lt;'t&gt; {
    /// Semantic action for non-terminal 'Variable'
    fn variable(&amp;mut self, _arg: &amp;Variable&lt;'t&gt;) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    /// Semantic action for non-terminal 'Precedence'
    fn precedence(&amp;mut self, arg: &amp;Precedence&lt;'t&gt;) -&gt; Result&lt;()&gt; {
        self.precedence = Some(arg.clone());
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now you can handle any variable. Because our grammar has no assignment yet, the function is simple.
It tries to retrieve the variables value from the <code>env</code>. If the variable is not found in the <code>env</code>
it creates a new entry with default value 0. Then it pushes this value on the <code>calc_results</code> vector
for later processing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Semantic action for non-terminal 'Variable'
    fn variable(&amp;mut self, var: &amp;Variable&lt;'t&gt;) -&gt; Result&lt;()&gt; {
        // Try to find the variable in the environment
        let value = if let Some(value) = self.env.get(var.variable.text()) {
            *value
        } else {
            // Insert default value for unassigned variable
            self.env
                .insert(var.variable.text().to_string(), DefinitionRange::default());
            DefinitionRange::default()
        };
        self.calc_results.push(value);
        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
<p>Don't forget to <code>use</code> the type <code>Variable</code> from the module <code>precedence_grammar_trait</code>.</p>
<p>To see the results modify the Display implementation of <code>PrecedenceGrammar</code> to show the intermediate
results and the environment.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Display for PrecedenceGrammar&lt;'_&gt; {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::result::Result&lt;(), Error&gt; {
        writeln!(
            f,
            "Result stack\n{}",
            self.calc_results
                .iter()
                .rev()
                .map(|e| format!("{}", e))
                .collect::&lt;Vec&lt;String&gt;&gt;()
                .join("\n")
        )?;
        writeln!(
            f,
            "\nEnv\n{}",
            self.env
                .iter()
                .map(|(i, v)| format!("{} = {}", i, v))
                .collect::&lt;Vec&lt;String&gt;&gt;()
                .join("\n")
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">    cargo run ./test.txt
Parsing took 0 milliseconds.
Success!
Result stack
0

Env
x = 0
</code></pre>
<p>As expected the variable <code>x</code> has been inserted into the environment with default value 0.
The Value 0 is still on the stack.</p>
<p>Now the next step could be to implement the semantic action for non-terminal <code>Literal</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Semantic action for non-terminal 'Literal'
    fn literal(&amp;mut self, lit: &amp;Literal&lt;'t&gt;) -&gt; Result&lt;()&gt; {
        // Convert the integer literal to its value
        let lit = lit
            .literal
            .text()
            .parse::&lt;DefinitionRange&gt;()
            .map_err(|e| parol!(format!("Cannot convert literal to integer: {}", e)))?;
        // Push it onto the calculation stack
        self.calc_results.push(lit);
        Ok(())
    }
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">    cargo run ./test.txt
Parsing took 0 milliseconds.
Success!
Result stack
5
0
1

Env
x = 0
</code></pre>
<p>Now I think you could continue on your own. Implement the binary operations by taking the two top
most numbers from the calculation stack and push the result on the stack again.
If all is implemented correctly the end result of the calculation should be laying as single value
on top of the calculation stack.</p>
<p><code>-1 + x * 5</code> should the result into <code>-1 + 0 * 5</code> =&gt; <code>-1</code>.</p>
<p>Now you could add assignments to your Grammar to be able to use variables to store and access values.
Allow the grammar to contain multiple operations and remove assigned values from the calculation
stack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-associativity"><a class="header" href="#operator-associativity">Operator Associativity</a></h1>
<p>Operator associativity defines the direction in which <strong>operators of the same precedence</strong> are
evaluated.</p>
<h2 id="left-associativity"><a class="header" href="#left-associativity">Left Associativity</a></h2>
<p>Left associativity means operators are grouped from the left. For example, <code>x * y * z</code> is evaluated
as <code>(x * y) * z</code>.</p>
<p>Consider this example grammar, which supports left-associative multiplication:</p>
<pre><code class="language-parol">%start LeftAssociativity
%title "Operator associativity"
%comment "Shows the handling of operator associativity in `parol`"

%%

Literal : /[0-9]+/ ;

// ---------------------------------------------------------
// OPERATOR SYMBOLS
MulOp   : '*' ;

// ---------------------------------------------------------
// EXPRESSIONS
LeftAssociativity : Multiplication ;

Multiplication : Literal { MulOp Literal } ;
</code></pre>
<p>To try this grammar:</p>
<pre><code class="language-shell">parol new --bin --path .\left_associativity --tree
</code></pre>
<p>Replace the generated dummy grammar with the example above. Set <code>test.txt</code> to:</p>
<pre><code class="language-text">5 * 6 * 2
</code></pre>
<p>Parse the text by running:</p>
<pre><code class="language-shell">cargo run ./test.txt
</code></pre>
<p>from the root of the generated crate.</p>
<p>Parsing <code>5 * 6 * 2</code> produces this parse tree:</p>
<p><img src="./left_associativity/test.svg" alt="Parse Tree" /></p>
<p>At first glance, the parse tree may appear to impose right associativity (evaluated right to left).
However, in <code>parol</code>, <strong>all repetitive grammar constructs are represented as vectors in AST types</strong>.</p>
<p>Example from the generated types in <code>src/left_associativity_grammar_trait.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Type derived for non-terminal Multiplication
pub struct Multiplication&lt;'t&gt; {
    pub literal: Box&lt;Literal&lt;'t&gt;&gt;,
    pub multiplication_list: Vec&lt;MultiplicationList&lt;'t&gt;&gt;,
}

/// Type derived for non-terminal MultiplicationList
pub struct MultiplicationList&lt;'t&gt; {
    pub mul_op: Box&lt;MulOp&lt;'t&gt;&gt;,
    pub literal: Box&lt;Literal&lt;'t&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Items in repetitions (<code>{...}</code>) are stored in vectors and can be processed in the desired direction.
This behavior applies to all grammar repetitions.</p>
<p>It is up to your grammar processing to choose the evaluation direction. To implement left
associativity, apply these changes to <code>src/left_associativity_grammar.rs</code>:</p>
<p>Replace the use statements at the top of the file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::left_associativity_grammar_trait::{
    LeftAssociativity, LeftAssociativityGrammarTrait, Literal,
};
use parol_runtime::Result;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{bail, parol};
use std::fmt::{Debug, Display, Error, Formatter};
<span class="boring">}</span></code></pre></pre>
<p>Add a <code>result</code> member to the struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LeftAssociativityGrammar&lt;'t&gt; {
    pub left_associativity: Option&lt;LeftAssociativity&lt;'t&gt;&gt;,
    pub result: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>Add these functions to the <code>impl LeftAssociativityGrammar&lt;'_&gt;</code> block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn number(literal: &amp;Literal) -&gt; Result&lt;u32&gt; {
    literal
        .literal
        .text()
        .parse::&lt;u32&gt;()
        .map_err(|e| parol!("'{}': {e}", literal.literal.text()))
}

fn process_operation(&amp;mut self) -&gt; Result&lt;()&gt; {
    if let Some(grammar) = &amp;self.left_associativity {
        let init = Self::number(&amp;grammar.multiplication.literal)?;
        self.result = grammar
            .multiplication
            .multiplication_list
            .iter()
            .try_fold(init, |acc, mul| -&gt; Result&lt;u32&gt; {
                Ok(acc * Self::number(&amp;mul.literal)?)
            })?;
        Ok(())
    } else {
        bail!("No valid parse result!")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Update the <code>Display</code> implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Display for LeftAssociativityGrammar&lt;'_&gt; {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::result::Result&lt;(), Error&gt; {
        match &amp;self.left_associativity {
            Some(_) =&gt; writeln!(f, "{}", self.result),
            None =&gt; write!(f, "No parse result"),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Change the last line of the <code>left_associativity</code> function from:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Ok(())
<span class="boring">}</span></code></pre></pre>
<p>to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    self.process_operation()
<span class="boring">}</span></code></pre></pre>
<p>Run the parser again:</p>
<pre><code class="language-shell">cargo run ./test.txt
</code></pre>
<p>Sample output:</p>
<pre><code>Parsing took 0 milliseconds.
Success!
60
</code></pre>
<p>The parser correctly calculates the result: <strong>60</strong>.</p>
<p>The key part is the <code>process_operation</code> function, which folds the multiplication results into
<code>result</code>. The initial value is the first element (<code>literal</code>) of the <code>Multiplication</code> struct,
matching the grammar structure:</p>
<pre><code class="language-parol">Multiplication : Literal { MulOp Literal } ;
</code></pre>
<h2 id="right-associativity"><a class="header" href="#right-associativity">Right Associativity</a></h2>
<p>Right associativity means operators are grouped from the right. For example, <code>x ^ y ^ z</code> is
evaluated as <code>x ^ (y ^ z)</code>.</p>
<p>Here is a grammar for right-associative potentiation:</p>
<pre><code class="language-parol">%start RightAssociativity
%title "Operator associativity"
%comment "Shows the handling of operator associativity in `parol`"

%%

Literal : /[0-9]+/ ;

// ---------------------------------------------------------
// OPERATOR SYMBOLS
PowOp   : '^' ;

// ---------------------------------------------------------
// EXPRESSIONS
RightAssociativity : Potentiation ;

Potentiation : Literal { PowOp Literal } ;
</code></pre>
<p>To try this grammar:</p>
<pre><code class="language-shell">parol new --bin --path .\right_associativity --tree
</code></pre>
<p>Replace the generated dummy grammar with the example above. Set <code>test.txt</code> to:</p>
<pre><code class="language-text">4 ^ 3 ^ 2
</code></pre>
<p>Parse the text by running:</p>
<pre><code class="language-shell">cargo run ./test.txt
</code></pre>
<p>from the root of the generated crate.</p>
<p>Parsing <code>4 ^ 3 ^ 2</code> produces this parse tree:</p>
<p><img src="./right_associativity/test.svg" alt="Parse Tree" /></p>
<p>The parse tree structure is identical to the left-associative example. <code>parol</code> handles all
repetitive constructs as vectors.</p>
<p>To implement right associativity, modify <code>src/right_associativity_grammar.rs</code> as in the
left-associativity example, changing prefixes from <code>Left</code>/<code>left_</code> to <code>Right</code>/<code>right_</code>.</p>
<p>Replace the <code>process_operation</code> function with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_operation(&amp;mut self) -&gt; Result&lt;()&gt; {
    if let Some(grammar) = &amp;self.right_associativity {
        self.result = grammar
            .potentiation
            .potentiation_list
            .iter()
            .rev()
            .try_fold(1, |acc, mul| -&gt; Result&lt;u32&gt; {
                Ok(Self::number(&amp;mul.literal)?.pow(acc))
            })?;
        let last = Self::number(&amp;grammar.potentiation.literal)?;
        self.result = last.pow(self.result);
        Ok(())
    } else {
        bail!("No valid parse result!")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the fold is performed in reverse order (<code>.rev()</code>), starting with <code>1</code>, and the last operand is
the single literal in the <code>Potentiation</code> struct.</p>
<p>Run the parser again:</p>
<pre><code class="language-shell">cargo run ./test.txt
</code></pre>
<p>Sample output:</p>
<pre><code>Parsing took 0 milliseconds.
Success!
262144
</code></pre>
<p>The parser correctly calculates the result: <strong>262144</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ast-generation"><a class="header" href="#ast-generation">AST Generation</a></h1>
<p><code>parol</code> can automatically generate all types implied by your grammar. It analyzes every production
in your grammar.</p>
<h2 id="grammar-transformation"><a class="header" href="#grammar-transformation">Grammar Transformation</a></h2>
<p>The first step is to canonicalize your grammar by applying the following transformations:</p>
<ul>
<li>All EBNF constructs—optional elements, repetitions, and groupings—are replaced with equivalent
representations:
<ul>
<li><code>A: [B];</code> → <code>A: BOpt; BOpt: B; BOpt: ;</code></li>
<li><code>A: {B};</code> → <code>A: BList; BList: B BList; BList: ;</code></li>
<li><code>A: (B);</code> → <code>A: BGroup; BGroup: B;</code></li>
</ul>
</li>
<li>Alternations are expanded into multiple productions:
<ul>
<li><code>A: B | C;</code> → <code>A: B; A: C;</code></li>
</ul>
</li>
</ul>
<p>These transformations are applied iteratively until all EBNF constructs are eliminated.</p>
<p>Note: Transformations for LR grammars differ slightly, but the principle remains the same.</p>
<h2 id="sanity-checks"><a class="header" href="#sanity-checks">Sanity Checks</a></h2>
<p>Next, <code>parol</code> checks the transformed grammar for properties that would prevent successful processing:</p>
<ul>
<li>Left recursion</li>
<li>Non-productive non-terminals</li>
<li>Unreachable non-terminals</li>
</ul>
<p>If none of these issues are present, the grammar is left-factored to reduce the number of required
lookahead symbols.</p>
<h2 id="the-expanded-grammar"><a class="header" href="#the-expanded-grammar">The Expanded Grammar</a></h2>
<p>The fully transformed grammar serves as the basis for parser generation and is typically saved for
reference. By convention, this "expanded" grammar is stored in files named <code>&lt;original-name&gt;-exp.par</code>.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>With the transformed grammar, all productions take the form:</p>
<pre><code>[v: s*;]
</code></pre>
<p>where \(v \epsilon V, s \epsilon (V \cup \Sigma)\), \(V\) is the set of non-terminals,
\(\Sigma\) is the set of terminals.</p>
<p>At this stage, the relationship between generated productions and their original EBNF constructs is
lost.</p>
<p>However, since it is necessary to know if a set of productions originated from an optional construct
(<code>[...]</code>), <code>parol</code> maintains this relationship throughout the transformation process. This allows it
to infer types such as Rust's <code>Option&lt;T&gt;</code>.</p>
<p>For example, using the transformation above:</p>
<p><code>A: [B];</code> → <code>A: BOpt; BOpt: B; BOpt: ;</code> → <code>typeof A = Option&lt;typeof B&gt;</code></p>
<p>If non-terminal <code>A</code> has only one production, its type is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    b: Option&lt;B&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>struct</code> is used because productions may have multiple elements on the right-hand side, each
becoming a separate member.</p>
<p>If non-terminal <code>A</code> has multiple productions, its type becomes a Rust <code>enum</code> with one variant per
production:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct B {
    // ...
}
struct C {
    // ...
}
// Type of non-terminal A
enum A {
    A0(B),
    A1(C),
}
<span class="boring">}</span></code></pre></pre>
<p>Once all types for non-terminals are inferred, <code>parol</code> generates an overall AST type as a Rust <code>enum</code>.
This enum contains one variant for each non-terminal type and is mainly used by the parser to
instantiate a typed parse stack. Users rarely need to interact with this AST enum directly.</p>
<h3 id="recursive-structure-of-a-grammar"><a class="header" href="#recursive-structure-of-a-grammar">Recursive Structure of a Grammar</a></h3>
<p>Context-free grammars are typically defined using recursive constructs. However, Rust does not allow
directly recursive types, as this would result in infinite type sizes.</p>
<p>To address this, <code>parol</code> generates boxed types for non-terminals when adding elements to structs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    b: Box&lt;B&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>This ensures finite type sizes.</p>
<p><code>parol</code> can minimize the use of boxed types in the generated parser. The tool supports a
command-line switch (<code>-b</code>, <code>--min_boxes</code>) to enable box minimization. The <code>parol::build::Builder</code>
also provides a <code>minimize_boxed_types()</code> method for use in build scripts.</p>
<p><code>parol</code> determines where recursion cannot occur by analyzing the grammar structure.</p>
<h2 id="managing-ast-generation"><a class="header" href="#managing-ast-generation">Managing AST Generation</a></h2>
<h3 id="omission-of-elements"><a class="header" href="#omission-of-elements">Omission of Elements</a></h3>
<p>You can suffix grammar symbols (terminals and non-terminals) with a cut operator (<code>^</code>) to prevent
them from being included in the AST type. For example:</p>
<pre><code class="language-parol">Group: '('^ Alternations ')'^;
</code></pre>
<p>The AST type for <code>Group</code> will only contain a member for the non-terminal <code>Alternations</code>. The
parentheses are omitted since they are not needed for grammar processing.</p>
<h3 id="assigning-user-types"><a class="header" href="#assigning-user-types">Assigning User Types</a></h3>
<p>You can specify a user type to be inserted into the AST structure in place of the automatically
generated type. Add a colon followed by a user type name after a grammar symbol to instruct <code>parol</code>
to use this type. In your implementation, provide fallible conversions from references of the
original generated types (<code>&amp;T</code>) to your types (<code>U</code>) by implementing the trait <code>TryFrom&lt;&amp;T&gt; for U</code>.
See the <code>list</code> example for details.</p>
<p>You can also define aliases for user type names using <code>%user_type</code> directives. Use these aliases
after the colons.</p>
<p>See the <a href="https://github.com/jsinger67/parol/blob/main/examples/list/list.par">list example</a> for user
type handling:</p>
<pre><code class="language-parol">%start List
%title "A possibly empty comma separated list of integers"
%comment "A trailing comma is allowed."
%user_type Number = crate::list_grammar::Number
%user_type Numbers = crate::list_grammar::Numbers
%line_comment "//"

%%

List: [Items: Numbers] TrailingComma^;
Items: Num {","^ Num};
Num: "0|[1-9][0-9]*": Number;
TrailingComma: [","^];
</code></pre>
<p>In this grammar, the terminal in the <code>Num</code> production is assigned to the user type <code>Number</code>, which
is an alias for <code>crate::list_grammar::Number</code>. The non-terminal <code>Items</code> is assigned to the user type
<code>Numbers</code>, an alias for <code>crate::list_grammar::Numbers</code>.</p>
<p>The parser generator replaces the automatically inferred type with the user-provided type and calls
the conversion from the original type to the user type during parsing.</p>
<p>The original type is the type of the source item in the grammar—terminal or non-terminal. See the
generated semantic action for production 1 of the expanded grammar <code>list-exp.par</code> in the traits file
<code>examples\list\list_grammar_trait.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Semantic action for production 1:
///
/// `ListOpt /* Option&lt;T&gt;::Some */: Items : Numbers;`
///
#[parol_runtime::function_name::named]
fn list_opt_0(&amp;mut self, _items: &amp;ParseTreeType&lt;'t&gt;) -&gt; Result&lt;()&gt; {
    let context = function_name!();
    trace!("{}", self.trace_item_stack(context));
    let items = pop_item!(self, items, Items, context);
    let list_opt_0_built = ListOpt {
        items: (&amp;items)
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?,
    };
    self.push(ASTType::ListOpt(Some(list_opt_0_built)), context);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>After tracing, the original item is popped from the parse stack. Its Rust type is <code>Items</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Type derived for non-terminal Items
pub struct Items {
    pub num: Box&lt;Num&gt;,
    pub items_list: Vec&lt;ItemsList&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>When constructing the <code>ListOpt</code> structure, the conversion to the user type is called:
<code>(&amp;items).try_into()</code>.</p>
<p>The <code>TryFrom</code> trait is provided by the user. See <code>examples\list\list_grammar.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TryFrom&lt;&amp;Items&gt; for Numbers {
    type Error = anyhow::Error;

    fn try_from(items: &amp;Items) -&gt; std::result::Result&lt;Self, Self::Error&gt; {
        Ok(Self(items.items_list.iter().fold(
            vec![items.num.num.0],
            |mut acc, e| {
                acc.push(e.num.num.0);
                acc
            },
        )))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This demonstrates how non-terminal types are converted into user types.</p>
<p>For terminals (tokens), conversion is simpler. See <code>examples\list\list_grammar.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'t&gt; TryFrom&lt;&amp;Token&lt;'t&gt;&gt; for Number {
    type Error = anyhow::Error;

    fn try_from(number: &amp;Token&lt;'t&gt;) -&gt; std::result::Result&lt;Self, Self::Error&gt; {
        Ok(Self(number.text().parse::&lt;u32&gt;()?))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the scanned text of the token is accessed using the <code>text</code> method of the <code>Token</code> type from
<code>parol_runtime</code>. The text is parsed into a <code>u32</code> and wrapped in a <code>Number</code> newtype.</p>
<p>By implementing <code>TryFrom</code> traits for your user types, you can easily integrate them into the parse
process.</p>
<p>Several examples are available to help you become familiar with this concept. You may also review
the <a href="https://github.com/jsinger67/parol/tree/main/examples/basic_interpreter">basic interpreter example</a>.</p>
<blockquote>
<p>For a complete list of ways to control AST type generation, see:
<a href="./ParGrammar.html#controlling-the-ast-generation">Controlling the AST generation</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semantic-actions-1"><a class="header" href="#semantic-actions-1">Semantic actions</a></h1>
<p>The <code>parol</code> parser generator creates traits with functions that represent semantic actions.
The generated parser then calls these functions at parse time at the appropriate points with correct
arguments.</p>
<p>The generated trait for user actions (i.e. semantic actions) will be named after the following
scheme:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait &lt;NameOfYourGrammar&gt;GrammarTrait&lt;'t&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The lifetime parameter <code>&lt;'t&gt;</code> can be left out if the types used don't hold references to the scanned
text. This is automatically deduced.</p>
<p>Eventually your grammar processing item implements this trait and can overwrite those functions of
the trait in which it is interested in.</p>
<p>It doesn't need to implement all trait functions because the trait is created in a way where all of
its functions have default implementations.</p>
<p>All semantic actions are generated for non-terminals of your input grammar, and are typed accordingly.</p>
<p>The <code>parol</code> parser generator creates a trait with functions that represent semantic actions. Here,
the semantic actions are typed and they are generated for the <em>non-terminals of your input grammar</em>
instead of for <em>productions of the <a href="AstGeneration.html#the-expanded-grammar">expanded grammar</a></em>.</p>
<p>You therefore don't have to mess around with <code>ParseTreeType</code> although you still encounter items of
type <code>Token</code>. Also the expanded version of your grammar is much less of interest for you.</p>
<p><code>parol</code>'s great merit is that it can generate an adapter layer automatically that provides the
conversion to typed grammar items. Indeed I carved out some simple rules that can be applied
universally to provide this layer of abstraction by generating the production bound semantic
actions accordingly.</p>
<p>This and the automatic AST type inference are the most outstanding properties of <code>parol</code>.</p>
<p>We will use the example
<a href="https://github.com/jsinger67/parol/tree/main/examples/calc">calc</a> for detailed explanations.</p>
<p>The file
<a href="https://github.com/jsinger67/parol/blob/main/examples/calc/calc_grammar_trait.rs">calc_grammar_trait.rs</a>
contains the generated traits and types we are interested in.</p>
<p>First we will have a look at the <code>CalcGrammarTrait</code> at the top of this file. For each non-terminal
of the input grammar
<a href="https://github.com/jsinger67/parol/blob/main/examples/calc/calc.par">calc.par</a> it contains exactly
one semantic action.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait CalcGrammarTrait&lt;'t&gt; {
    /// Semantic action for non-terminal 'Calc'
    fn calc(&amp;mut self, _arg: &amp;Calc&lt;'t&gt;) -&gt; Result&lt;()&gt; {
        Ok(())
    }
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The approach taken in this example is quite interesting. We only implement the semantic action for
the start symbol of our grammar: <em>Calc</em>.</p>
<p>The implementation can be found in
<a href="https://github.com/jsinger67/parol/blob/main/examples/calc/calc_grammar.rs">calc_grammar.rs</a>.</p>
<p>Near the end you can find the one and only semantic action we implement here and thereby creating
the functionality of a calculator language.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'t&gt; CalcGrammarTrait&lt;'t&gt; for CalcGrammar&lt;'t&gt; {
    /// Semantic action for non-terminal 'Calc'
    fn calc(&amp;mut self, arg: &amp;Calc&lt;'t&gt;) -&gt; Result&lt;()&gt; {
        self.process_calc(arg)?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>But what is the advantage of implementing only the start symbols's semantic action? Well, since the
start symbol is the root node of each and every concrete parse tree, we know that the generated type
for it should comprise the complete input as the result of the parsing.</p>
<p>The key to this is the structure of the generated type <code>Calc</code>. It resembles the structure of all
productions belonging to the non-terminal <code>Calc</code>. There is actually only one production for <code>Calc</code>:</p>
<pre><code class="language-parol">Calc: { Instruction ";"^ };
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///
/// Type derived for non-terminal Calc
///
pub struct Calc&lt;'t&gt; {
    pub calc_list: Vec&lt;CalcList&lt;'t&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The type <code>Calc</code> is basically a vector, which can be deduced from the repetition construct at the
right-hand side of the production (<code>{ Instruction ";"^ }</code>).</p>
<p>The elements of the vector are of type <code>CalcList</code> that is defined this way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///
/// Type derived for non-terminal calcList
///
pub struct CalcList&lt;'t&gt; {
    pub instruction: Instruction&lt;'t&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>And in turn the type <code>Instruction</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///
/// Type derived for non-terminal instruction
///
pub enum Instruction&lt;'t&gt; {
    Assignment(InstructionAssignment&lt;'t&gt;),
    LogicalOr(InstructionLogicalOr&lt;'t&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>The latter one is an enum with two variants because the non-terminal <code>Instruction</code> has two
productions:</p>
<pre><code class="language-parol">// ---------------------------------------------------------
// INSTRUCTION
Instruction: Assignment;
Instruction: LogicalOr;
</code></pre>
<p>This concept is applied for all non-terminals of your grammar. Actually your grammar became
<em>typified</em>.</p>
<p>This means eventually that any variable of type <code>Calc</code> can represent a validly parsed input sentence
that belongs to the grammar defined by
<a href="https://github.com/jsinger67/parol/blob/main/examples/calc/calc.par">calc.par</a>.</p>
<p>You then only have to evaluate the content of this value as done in this calculator example.
I recommend to study this example more deeply and the approach will become obvious to you.</p>
<p>As mentioned earlier the implementation can be found here:
<a href="https://github.com/jsinger67/parol/blob/main/examples/calc/calc_grammar.rs">calc_grammar.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-tips"><a class="header" href="#useful-tips">Useful Tips</a></h1>
<h2 id="build-performance"><a class="header" href="#build-performance">Build Performance</a></h2>
<p>To optimize build performance when using <code>parol</code>'s <a href="https://github.com/jsinger67/parol/blob/main/crates/parol/src/build.rs">Builder</a> API in your <code>build.rs</code> script, add the following overrides to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml"># Optimized build performance
[profile.dev.build-override]
opt-level = 3

[profile.release.build-override]
opt-level = 3
</code></pre>
<h4 id="credits"><a class="header" href="#credits">Credits</a></h4>
<p>Thanks to <a href="https://github.com/dalance">dalance</a> for reporting <a href="https://github.com/jsinger67/parol/issues/49">issue #49 (build.rs performance)</a>.</p>
<h2 id="parser-generation-performance"><a class="header" href="#parser-generation-performance">Parser Generation Performance</a></h2>
<p>The need to frequently regenerate the parser from a grammar is greatly reduced in <code>parol</code> due to its design. <code>parol</code> generates data structures for your grammar, an interface, and the plumbing to call its methods. This separates parser generation from any code you write to process your grammar, such as the interface's implementation.</p>
<blockquote>
<p>This feature enables ad hoc generation of acceptors for any valid grammar, which can be considered <em>rapid prototyping</em> for your grammar.</p>
</blockquote>
<p>You only need to regenerate the parser when you change your grammar description (i.e., your <code>.par</code> file). If parser generation is expensive for your grammar, consider placing the generated parser and user trait under source control.</p>
<p>It is beneficial to design your grammar to be LL(k) with the smallest possible k. Although this can be challenging, it is worthwhile.</p>
<p>Also, optimize your grammar for a minimal number of productions. Consider these guidelines:</p>
<ul>
<li>Avoid productions that only rename a non-terminal, such as:
<pre><code class="language-parol">A: B;
</code></pre>
</li>
<li>Disambiguate your productions and avoid duplications like:
<pre><code class="language-parol">A: X Y Z;
B: X Y Z;
</code></pre>
Determine why you need productions with identical right-hand sides. If they are actually the same, consider unifying them.</li>
</ul>
<p>If you have a historical grammar definition that is left-recursive (common in Yacc/Bison grammar descriptions), allow extra time and effort to convert it to a right-recursive form.</p>
<p>Alternatively, you can use LALR(1) grammars without sacrificing the convenience of <code>parol</code>. See the <a href="https://jsinger67.github.io/ParGrammar.html#defining-the-grammar-type">grammar type specification</a>.</p>
<p><code>parol</code> currently does not provide special support for this phase, except for detecting left recursions in your grammar.</p>
<p>Support for removing direct left recursions may be provided in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-and-answers"><a class="header" href="#questions-and-answers">Questions and answers</a></h1>
<h2 id="q-i-get-stack-overflow-in-compiler-generated-traits-like-drop-clone-and-debug"><a class="header" href="#q-i-get-stack-overflow-in-compiler-generated-traits-like-drop-clone-and-debug">Q: I get stack overflow in compiler generated trait's like <code>Drop</code>, <code>Clone</code> and <code>Debug</code></a></h2>
<p>A: The reason is most likely a deeply nested structure generated during parsing. There are two
advices which could lead to working solution:</p>
<ol>
<li>Avoid 'plain' recursions in your grammar like this (for LL(k) grammars):</li>
</ol>
<pre><code class="language-parol">List: ListItem List;
List: ;
ListItem: Number;
Number: /0|[1-9][0-9]*/;
</code></pre>
<p>This will generate recursive data structures like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum List&lt;'t&gt; {
    ListItemList(ListListItemList&lt;'t&gt;),
    ListEmpty(ListListEmpty),
}
pub struct ListListItemList&lt;'t&gt; {
    pub list_item: Box&lt;ListItem&lt;'t&gt;&gt;,
    pub list: Box&lt;List&lt;'t&gt;&gt;,
}
pub struct Number&lt;'t&gt; {
    pub number: Token&lt;'t&gt;, /* 0|[1-9][0-9]* */
}
<span class="boring">}</span></code></pre></pre>
<p>The recursion occurs here by containing <code>List</code> in <code>ListListItemList</code>.</p>
<p>Use instead <code>parol</code>'s own repetition construct (<code>{...}</code>), which will result in the generation of a data type
containing a vector.</p>
<pre><code class="language-parol">List: { ListItem };
ListItem: Number;
Number: /0|[1-9][0-9]*/: Number;
</code></pre>
<p>This will generate iterative data structures like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct List&lt;'t&gt; {
    pub list_list: Vec&lt;ListList&lt;'t&gt;&gt;,
}
pub struct ListList {
    pub list_item: Box&lt;ListItem&gt;,
}
pub struct ListItem&lt;'t&gt; {
    pub number: Box&lt;Number&lt;'t&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Implement the problematic traits by yourself and avoid the recursion by using a loop instead.
I can't give a general advice here, but there are plenty examples out there that cover this topic
thoroughly.</li>
</ol>
<h2 id="q-i-get-strange-errors-while-commissioning-my-new-grammar-and-cant-figure-out-what-the-problem-is"><a class="header" href="#q-i-get-strange-errors-while-commissioning-my-new-grammar-and-cant-figure-out-what-the-problem-is">Q: I get strange errors while commissioning my new grammar and can't figure out what the problem is</a></h2>
<p>A: Consider the following advices</p>
<h3 id="break-down-the-problem-with-a-least-input-as-possible"><a class="header" href="#break-down-the-problem-with-a-least-input-as-possible">Break down the problem with a least input as possible</a></h3>
<p>This will limit the possible error location and also minimize the amount of traces to scrutinize.</p>
<h3 id="disable-error-recovery-for-llk-parsers"><a class="header" href="#disable-error-recovery-for-llk-parsers">Disable error recovery for LL(k) parsers</a></h3>
<p>The process of error recovery will surely shroud the original error location.
Therefore it is advisable to temporarily disable it.</p>
<p>Use Builder API (<code>disable_recovery()</code>) or command line argument (<code>--disable-recovery</code>).</p>
<h3 id="enable-traces"><a class="header" href="#enable-traces">Enable traces</a></h3>
<p>In all projects that were generated with <code>parol new</code> the env_logger is built in. First activate all
traces. I'll show the principle in powershell because this will work on Windows as well as on Linux</p>
<pre><code class="language-powershell">$env:RUST_LOG="trace"
</code></pre>
<p>Then run your scenario and examine the output. If necessary restrict the traces further by tweaking
the RUST_LOG variable, e.g. for parser and scanner internals use this:</p>
<pre><code class="language-powershell">$env:RUST_LOG="parol_runtime=trace"
# or
$env:RUST_LOG="parol_runtime::lexer=trace"
# or
$env:RUST_LOG="parol_runtime::parser=trace"
# or
$env:RUST_LOG="parol_runtime::lr_parser=trace"
</code></pre>
<ul>
<li>Examine the traces from the beginning to pin down the first occurrence of the problem</li>
<li>Often the problems are related to wrong terminal definitions or terminal conflicts or evens
scanner state related problems, therefore
<ul>
<li>Check for token types attached to the tokens provided during parse, the numbers can be found
in the generated parser</li>
<li>Check the current scanner state and if the tokens are valid there</li>
</ul>
</li>
</ul>
<h2 id="q-i-get-warnings-in-generated-code-this-function-has-too-many-arguments"><a class="header" href="#q-i-get-warnings-in-generated-code-this-function-has-too-many-arguments">Q: I get warnings in generated code 'This function has too many arguments'</a></h2>
<p>A: Configure the builder in your <code>build.rs</code> to let <code>parol</code> generate a</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(clippy::too_many_arguments)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>line at the beginning of your generated file.</p>
<p>Add this line in the builder configuration somewhere before the call to <code>.generate_parser()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        .inner_attributes(vec![InnerAttributes::AllowTooManyArguments])
<span class="boring">}</span></code></pre></pre>
<p>Don't forget to import the <code>InnerAttributes</code> into your <code>build.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use parol::{build::Builder, InnerAttributes, ParolErrorReporter};
<span class="boring">}</span></code></pre></pre>
<p>Another way to avoid this waring is to modify your grammar such that the lengths of the right-hand
sides of your productions are decreased. Therefore examine the productions that correlate to the
functions where the warnings occur. Then consider to factor out parts of the RHS into separate
productions.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
